type APIOptions = {
    params?: Record<string, unknown>;
    headers?: HeadersInit;
    kwargs?: Record<string, unknown>;
    handle?: boolean;
    data?: BodyInit | JSON;
    dataJ?: JSON;
    dataM?: Record<string, unknown>;
};

declare class API {
    constructor(kwargs?: Record<string, unknown>);
    get(url: string, options?: APIOptions): unknown;
    post(url: string, options?: APIOptions): unknown;
    put(url: string, options?: APIOptions): unknown;
    delete(url: string, options?: APIOptions): unknown;
    patch(url: string, options?: APIOptions): unknown;
    options(url: string, options?: APIOptions): unknown;
}

declare class YoniusError extends Error {
    code: number;
    constructor(message: string, code?: number);
    isClient(): boolean;
    isServer(): boolean;
}

declare class OperationalError extends YoniusError {
    constructor(message?: string, code?: number);
}

declare class NotFoundError extends OperationalError {}

declare class NotImplementedError extends OperationalError {}

declare class ValidationError extends OperationalError {}

declare function register(name: string, value: unknown): void;
declare function unregister(name: string): void;
declare function request(name: string): unknown;

declare class FileTuple extends Array {
    static fromData(data: Uint8Array, name?: string, mime?: string): FileTuple;
    static fromString(
        dataString: StringConstructor,
        name?: string,
        mime?: string,
        options?: { encoding?: string }
    ): FileTuple;

    static fromArrayBuffer(arrayBuffer: ArrayBuffer, name?: string, mime?: string): FileTuple;
    static fromBlob(blob: Blob, name?: string, mime?: string): Promise<FileTuple>;
    get name(): string;
    get mime(): string;
    get data(): Uint8Array;
}

interface QueryParams {
    readonly fields?: string[];
    readonly eager?: boolean;
    readonly eagerL?: boolean;
    readonly map?: boolean;
    readonly rules?: boolean;
    readonly meta?: boolean;
    readonly build?: boolean;
    readonly fill?: boolean;
    readonly resolveA?: boolean;
    readonly skip?: number;
    readonly limit?: number;
    readonly sort?: unknown[][];
    readonly raiseE?: boolean;
    [x: string]: unknown;
}

declare class Model {
    static niw<T = Model>(this: { new (): T }): T;
    static get<T = Model>(this: { new (): T }, params?: QueryParams): Promise<T>;
    static find<T = Model>(this: { new (): T }, params?: QueryParams): Promise<T[]>;
    static count<T = Model>(this: { new (): T }, params?: QueryParams): Promise<number>;

    constructor(options?: { fill?: boolean });
    apply<T = Model>(this: T, model: Record<string, unknown>): Promise<T>;
    save<T = Model>(this: T): Promise<T>;
    delete<T = Model>(
        this: T,
        options?: {
            preDelete?: boolean;
            postDelete?: boolean;
            beforeCallbacks?: ((self: T, model: Record<string, unknown>) => void)[];
            afterCallbacks?: ((self: T, model: Record<string, unknown>) => void)[];
        }
    ): Promise<T>;

    advance<T = Model>(this: T, name: string, delta: number): Promise<number>;
    reload<T = Model>(this: T, params?: QueryParams): Promise<T>;
    validate(): Promise<void>;
    _validate(): IterableIterator<Error>;
}

declare class ModelStore extends Model {
    static get schema(): Record<string, unknown>;
    static get idName(): string;
    preSave(): Promise<void>;
    preCreate(): Promise<void>;
    preUpdate(): Promise<void>;
    preDelete(): Promise<void>;
    postSave(): Promise<void>;
    postCreate(): Promise<void>;
    postUpdate(): Promise<void>;
    postDelete(): Promise<void>;
}

declare function verify(
    condition: boolean,
    message?: string,
    code?: number,
    exception?: Error,
    kwargs?: Record<string, unknown>,
    safeKeys?: string[]
): void;

enum Cast {
    int = "int",
    float = "float",
    bool = "bool",
    list = "list",
    tuple = "tuple"
}
declare function load(
    names?: string[],
    path?: string,
    encoding?: string,
    force?: boolean,
    ctx?: unknown
): Promise<void>;
declare function conf(
    name: string,
    fallback?: unknown,
    cast?: string,
    ctx?: unknown
): unknown;
declare function confP(
    name: string,
    fallback?: unknown,
    cast?: Cast | string,
    ctx?: unknown
): Promise<unknown>;

declare function getObject(
    params: Record<string, unknown>,
    options: {
        alias?: boolean;
        page?: boolean;
        find?: boolean;
        norm?: boolean;
    }
): Record<string, unknown>;

declare function initMongo(mongoose: unknown, uri: string): Promise<void>;

declare function destroyMongo(mongoose: unknown): void;

declare function camelToUnderscore(value: string, separator?: string): string;

declare function underscoreToCamel(
    value: string,
    lower?: boolean,
    separator?: string
): string;

declare function eq<T>(valueC: T, message?: string): (value?: T, ctx?: unknown) => boolean;

declare function gt<T>(valueC: T, message?: string): (value?: T, ctx?: unknown) => boolean;

declare function gte<T>(valueC: T, message?: string): (value?: T, ctx?: unknown) => boolean;

declare function notEmpty(
    message?: string
): (value?: string | unknown[], ctx?: unknown) => boolean;

declare function isIn<T>(
    valueC: T[],
    message?: string
): (value?: T, ctx?: unknown) => boolean;

declare function isUpper(message?: string): (value?: string, ctx?: unknown) => boolean;

declare function isLower(message?: string): (value?: string, ctx?: unknown) => boolean;

declare function isSimple(message?: string): (value?: string, ctx?: unknown) => boolean;

declare function isEmail(message?: string): (value?: string, ctx?: unknown) => boolean;

declare function isUrl(message?: string): (value?: string, ctx?: unknown) => boolean;

declare function isRegex(
    regex: string,
    message?: string
): (value?: string, ctx?: unknown) => boolean;

declare function stringGt(
    valueC: number,
    message?: string
): (value?: string, ctx?: unknown) => boolean;

declare function stringLt(
    valueC: number,
    message?: string
): (value?: string, ctx?: unknown) => boolean;

declare function stringEq(
    valueC: number,
    message?: string
): (value?: string, ctx?: unknown) => boolean;

export { API, Cast, FileTuple, Model, ModelStore, NotFoundError, NotImplementedError, OperationalError, QueryParams, ValidationError, YoniusError, camelToUnderscore, conf, confP, destroyMongo, eq, getObject, gt, gte, initMongo, isEmail, isIn, isLower, isRegex, isSimple, isUpper, isUrl, load, notEmpty, register, request, stringEq, stringGt, stringLt, underscoreToCamel, unregister, verify };
