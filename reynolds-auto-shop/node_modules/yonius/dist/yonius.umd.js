/**
 * Yonius 0.11.7.
 *
 * Copyright (c) 2008-2022 Hive Solutions Lda.
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.yonius = {}));
})(this, (function (exports) { 'use strict';

    var name = "yonius";
    var version = "0.11.7";

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }

      return target;
    }

    function _typeof(obj) {
      "@babel/helpers - typeof";

      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, _typeof(obj);
    }

    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }

      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }

    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
            args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);

          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }

          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }

          _next(undefined);
        });
      };
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }

      return _construct.apply(null, arguments);
    }

    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };

      return _wrapNativeSuper(Class);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }

      return _assertThisInitialized(self);
    }

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;

          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return _possibleConstructorReturn(this, result);
      };
    }

    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }

      return object;
    }

    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }

          return desc.value;
        };
      }

      return _get.apply(this, arguments);
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _toArray(arr) {
      return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;

      var _s, _e;

      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;

          var F = function () {};

          return {
            s: F,
            n: function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function (e) {
              throw e;
            },
            f: F
          };
        }

        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var normalCompletion = true,
          didErr = false,
          err;
      return {
        s: function () {
          it = it.call(o);
        },
        n: function () {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function (e) {
          didErr = true;
          err = e;
        },
        f: function () {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }

    var Observable = /*#__PURE__*/function () {
      function Observable() {
        _classCallCheck(this, Observable);

        this.callbacks = {};
      }

      _createClass(Observable, [{
        key: "bind",
        value: function bind(event, callback) {
          var callbacks = this.callbacks[event] || [];
          callbacks.push(callback);
          this.callbacks[event] = callbacks;
          return callback;
        }
      }, {
        key: "unbind",
        value: function unbind(event, callback) {
          var callbacks = this.callbacks[event] || [];

          if (!callback) {
            delete this.callbacks[event];
            return;
          }

          var index = callbacks.indexOf(callback);

          if (index === -1) {
            return;
          }

          callbacks.splice(index, 1);
          this.callbacks[event] = callbacks;
        }
      }, {
        key: "trigger",
        value: function trigger(event) {
          var callbacks = this.callbacks[event] || [];
          var results = [];

          var _iterator = _createForOfIteratorHelper(callbacks),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var callback = _step.value;
              var result = callback.apply(this, Array.prototype.slice.call(arguments, 1));
              result !== undefined && result !== null && results.push(result);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return Promise.all(results);
        }
      }]);

      return Observable;
    }();

    var verify = function verify(condition) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var exception = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var kwargs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      var safeKeys = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : ["message"];
      if (condition) return;
      message = message || "Verification failed";
      var Exception = exception || Error;
      kwargs = Object.assign({}, kwargs);
      if (message !== null && message !== undefined) kwargs.message = message;
      if (code !== null && message !== undefined) kwargs.code = code;
      var throwable = new Exception(kwargs.message || undefined);
      throwable.kwargs = kwargs;

      for (var _i = 0, _Object$entries = Object.entries(kwargs); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            key = _Object$entries$_i[0],
            value = _Object$entries$_i[1];

        if (safeKeys.includes(key) && throwable[key] !== undefined) {
          continue;
        }

        throwable[key] = value;
      }

      throw throwable;
    };
    var verifyEqual = function verifyEqual(first, second) {
      var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var code = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var exception = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var kwargs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
      message = message || "Expected ".concat(first, " got ").concat(second);
      return this.verify(first === second, message, code, exception, kwargs);
    };
    var verifyNotEqual = function verifyNotEqual(first, second) {
      var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var code = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var exception = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var kwargs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
      message = message || "Expected ".concat(first, " not equal to ").concat(second);
      return this.verify(first !== second, message, code, exception, kwargs);
    };
    var verifyMany = function verifyMany(sequence) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var exception = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var kwargs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      sequence.forEach(function (element) {
        verify(element, message, code, exception, kwargs);
      });
    };

    const promises = {};

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    function normalizeArray(parts, allowAboveRoot) {
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;

      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];

        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      } // if the path is allowed to go above the root, restore leading ..s


      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }

      return parts;
    } // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.


    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;

    var splitPath = function splitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }; // path.resolve([from ...], to)
    // posix version


    function resolve() {
      var resolvedPath = '',
          resolvedAbsolute = false;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : '/'; // Skip empty and invalid entries

        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }

        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      } // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
      // Normalize the path


      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
        return !!p;
      }), !resolvedAbsolute).join('/');
      return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
    }
    // posix version

    function normalize(path) {
      var isPathAbsolute = isAbsolute(path),
          trailingSlash = substr(path, -1) === '/'; // Normalize the path

      path = normalizeArray(filter(path.split('/'), function (p) {
        return !!p;
      }), !isPathAbsolute).join('/');

      if (!path && !isPathAbsolute) {
        path = '.';
      }

      if (path && trailingSlash) {
        path += '/';
      }

      return (isPathAbsolute ? '/' : '') + path;
    }

    function isAbsolute(path) {
      return path.charAt(0) === '/';
    } // posix version

    function join() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return normalize(filter(paths, function (p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }

        return p;
      }).join('/'));
    } // path.relative(from, to)
    function dirname(path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];

      if (!root && !dir) {
        // No dirname whatsoever
        return '.';
      }

      if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
      }

      return root + dir;
    }

    function filter(xs, f) {
      if (xs.filter) return xs.filter(f);
      var res = [];

      for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
      }

      return res;
    } // String.prototype.substr - negative index don't work in IE8


    var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
      return str.substr(start, len);
    } : function (str, start, len) {
      if (start < 0) start = str.length + start;
      return str.substr(start, len);
    };

    var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

    if (typeof global$1.setTimeout === 'function') ;

    if (typeof global$1.clearTimeout === 'function') ;
    var env = {};


    var performance = global$1.performance || {};

    performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
      return new Date().getTime();
    }; // generate timestamp or delta

    var HOME_DIR = null;
    var pathExists = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(path) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return promises.access(path);

              case 3:
                _context.next = 8;
                break;

              case 5:
                _context.prev = 5;
                _context.t0 = _context["catch"](0);
                return _context.abrupt("return", false);

              case 8:
                return _context.abrupt("return", true);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 5]]);
      }));

      return function pathExists(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    var expandUser = function expandUser(path) {
      if (!path) return path;
      if (path === "~") return _homeDir();
      if (path.slice(0, 2) !== "~/") return path;
      return join(HOME_DIR, path.slice(2));
    };
    var getEnv = function getEnv(name) {
      // eslint-disable-next-line no-undef
      if (typeof Deno !== "undefined") return Deno.env.get(name);
      return env[name];
    };
    var getEnvObject = function getEnvObject() {
      // eslint-disable-next-line no-undef
      if (typeof Deno !== "undefined") return Deno.env.toObject();
      return env;
    };

    var _homeDir = function _homeDir() {
      if (HOME_DIR !== null) return HOME_DIR;
      var isWindows = Boolean(typeof process !== "undefined" && process.platform === "win32");
      HOME_DIR = getEnv(isWindows ? "USERPROFILE" : "HOME") || "/";
      return HOME_DIR;
    };

    var FILE_NAME = "yonius.json";
    var HOME_FILE = "~/.home";
    var IMPORT_NAMES = ["$import", "$include", "$IMPORT", "$INCLUDE"];
    var CASTS = {
      "int": function int(v) {
        return typeof v === "number" ? v : parseInt(v);
      },
      "float": function float(v) {
        return typeof v === "number" ? v : parseFloat(v);
      },
      bool: function bool(v) {
        return typeof v === "boolean" ? v : ["1", "true", "True"].includes(v);
      },
      list: function list(v) {
        return Array.isArray(v) ? v : v.split(";");
      },
      tuple: function tuple(v) {
        return Array.isArray(v) ? v : v.split(";");
      }
    };
    var globals = typeof global === "undefined" ? typeof window === "undefined" ? typeof self === "undefined" ? {} : self : window : global;
    globals.CONFIGS = globals.CONFIGS === undefined ? {} : globals.CONFIGS;
    globals.CONFIG_F = globals.CONFIG_F === undefined ? [] : globals.CONFIG_F;
    globals.HOMES = globals.HOMES === undefined ? [] : globals.HOMES;
    globals.LOADED = globals.LOADED === undefined ? false : globals.LOADED;
    var conf = function conf(name) {
      var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var cast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var ctx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var configs = ctx ? ctx.configs : globals.CONFIGS;
      cast = _castR(cast);
      var value = configs[name] === undefined ? fallback : configs[name];
      if (cast && value !== undefined && value !== null) value = cast(value);
      return value;
    };
    var confP = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(name) {
        var fallback,
            cast,
            ctx,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                fallback = _args.length > 1 && _args[1] !== undefined ? _args[1] : undefined;
                cast = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                ctx = _args.length > 3 && _args[3] !== undefined ? _args[3] : null;
                _context.next = 5;
                return load$1();

              case 5:
                return _context.abrupt("return", conf(name, fallback, cast, ctx));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function confP(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    var confS = function confS(name, value) {
      var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var configs = ctx ? ctx.configs : globals.CONFIGS;
      configs[name] = value;
    };
    var load$1 = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var names,
            path,
            encoding,
            force,
            ctx,
            paths,
            homes,
            _iterator,
            _step,
            home,
            _iterator2,
            _step2,
            _path,
            _iterator3,
            _step3,
            name,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                names = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : [FILE_NAME];
                path = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;
                encoding = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : "utf-8";
                force = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : false;
                ctx = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : null;

                if (!(globals.LOADED && !force)) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return");

              case 7:
                paths = [];
                _context2.next = 10;
                return getHomes();

              case 10:
                homes = _context2.sent;
                _iterator = _createForOfIteratorHelper(homes);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    home = _step.value;
                    paths = paths.concat([join(home), join(home, ".config")]);
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                paths.push(path);
                _iterator2 = _createForOfIteratorHelper(paths);
                _context2.prev = 15;

                _iterator2.s();

              case 17:
                if ((_step2 = _iterator2.n()).done) {
                  _context2.next = 38;
                  break;
                }

                _path = _step2.value;
                _iterator3 = _createForOfIteratorHelper(names);
                _context2.prev = 20;

                _iterator3.s();

              case 22:
                if ((_step3 = _iterator3.n()).done) {
                  _context2.next = 28;
                  break;
                }

                name = _step3.value;
                _context2.next = 26;
                return loadFile(name, _path, encoding, ctx);

              case 26:
                _context2.next = 22;
                break;

              case 28:
                _context2.next = 33;
                break;

              case 30:
                _context2.prev = 30;
                _context2.t0 = _context2["catch"](20);

                _iterator3.e(_context2.t0);

              case 33:
                _context2.prev = 33;

                _iterator3.f();

                return _context2.finish(33);

              case 36:
                _context2.next = 17;
                break;

              case 38:
                _context2.next = 43;
                break;

              case 40:
                _context2.prev = 40;
                _context2.t1 = _context2["catch"](15);

                _iterator2.e(_context2.t1);

              case 43:
                _context2.prev = 43;

                _iterator2.f();

                return _context2.finish(43);

              case 46:
                _context2.next = 48;
                return loadEnv(ctx);

              case 48:
                globals.LOADED = true;

              case 49:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[15, 40, 43, 46], [20, 30, 33, 36]]);
      }));

      return function load() {
        return _ref2.apply(this, arguments);
      };
    }();
    var loadFile = /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var name,
            path,
            encoding,
            ctx,
            configs,
            configF,
            key,
            value,
            exists,
            filePath,
            basePath,
            data,
            dataJ,
            _i,
            _Object$entries,
            _Object$entries$_i,
            _args3 = arguments;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                name = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : FILE_NAME;
                path = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;
                encoding = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : "utf-8";
                ctx = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : null;
                configs = ctx ? ctx.configs : globals.CONFIGS;
                configF = ctx ? ctx.configF : globals.CONFIG_F;
                if (path) path = normalize(path);
                if (path) filePath = join(path, name);else filePath = name;
                filePath = resolve(filePath);
                filePath = normalize(filePath);
                basePath = dirname(filePath);
                _context3.next = 13;
                return pathExists(filePath);

              case 13:
                exists = _context3.sent;

                if (exists) {
                  _context3.next = 16;
                  break;
                }

                return _context3.abrupt("return");

              case 16:
                exists = configF.includes(filePath);
                if (exists) configF.splice(configF.indexOf(filePath), 1);
                configF.push(filePath);
                _context3.next = 21;
                return promises.readFile(filePath, {
                  encoding: encoding
                });

              case 21:
                data = _context3.sent;
                dataJ = JSON.parse(data);
                _context3.next = 25;
                return _loadIncludes(basePath, dataJ, encoding);

              case 25:
                _i = 0, _Object$entries = Object.entries(dataJ);

              case 26:
                if (!(_i < _Object$entries.length)) {
                  _context3.next = 36;
                  break;
                }

                _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2);
                key = _Object$entries$_i[0];
                value = _Object$entries$_i[1];

                if (_isValid(key)) {
                  _context3.next = 32;
                  break;
                }

                return _context3.abrupt("continue", 33);

              case 32:
                configs[key] = value;

              case 33:
                _i++;
                _context3.next = 26;
                break;

              case 36:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function loadFile() {
        return _ref3.apply(this, arguments);
      };
    }();
    var loadEnv = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var ctx,
            env,
            configs,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                ctx = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : null;
                env = getEnvObject();
                configs = ctx ? ctx.configs : globals.CONFIGS;

                if (!(env === undefined || env === null)) {
                  _context4.next = 5;
                  break;
                }

                return _context4.abrupt("return");

              case 5:
                Object.entries(env).forEach(function (_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 2),
                      key = _ref6[0],
                      value = _ref6[1];

                  configs[key] = value;
                });

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      return function loadEnv() {
        return _ref4.apply(this, arguments);
      };
    }();
    var getHomes = /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var filePath,
            fallback,
            encoding,
            forceDefault,
            env,
            exists,
            data,
            paths,
            _iterator4,
            _step4,
            path,
            _args5 = arguments;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                filePath = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : HOME_FILE;
                fallback = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : "~";
                encoding = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : "utf-8";
                forceDefault = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : false;

                if (!(globals.HOMES.length > 0)) {
                  _context5.next = 6;
                  break;
                }

                return _context5.abrupt("return", globals.HOMES);

              case 6:
                env = getEnvObject();
                globals.HOMES = env.HOMES === undefined ? null : env.HOMES;
                globals.HOMES = globals.HOMES ? globals.HOMES.split(";") : globals.HOMES;

                if (!(globals.HOMES !== null)) {
                  _context5.next = 11;
                  break;
                }

                return _context5.abrupt("return", globals.HOMES);

              case 11:
                fallback = expandUser(fallback);
                fallback = normalize(fallback);
                globals.HOMES = [fallback];
                filePath = expandUser(filePath);
                filePath = normalize(filePath);
                _context5.next = 18;
                return pathExists(filePath);

              case 18:
                exists = _context5.sent;

                if (exists) {
                  _context5.next = 21;
                  break;
                }

                return _context5.abrupt("return", globals.HOMES);

              case 21:
                if (!forceDefault) globals.HOMES.splice(0, globals.HOMES.length);
                _context5.next = 24;
                return promises.readFile(filePath, {
                  encoding: encoding
                });

              case 24:
                data = _context5.sent;
                data = data.trim();
                paths = data.split(/\r?\n/);
                paths = paths.map(function (v) {
                  return v.trim();
                });
                _iterator4 = _createForOfIteratorHelper(paths);
                _context5.prev = 29;

                _iterator4.s();

              case 31:
                if ((_step4 = _iterator4.n()).done) {
                  _context5.next = 41;
                  break;
                }

                path = _step4.value;
                path = path.trim();

                if (path) {
                  _context5.next = 36;
                  break;
                }

                return _context5.abrupt("continue", 39);

              case 36:
                path = expandUser(path);
                path = normalize(path);
                globals.HOMES.push(path);

              case 39:
                _context5.next = 31;
                break;

              case 41:
                _context5.next = 46;
                break;

              case 43:
                _context5.prev = 43;
                _context5.t0 = _context5["catch"](29);

                _iterator4.e(_context5.t0);

              case 46:
                _context5.prev = 46;

                _iterator4.f();

                return _context5.finish(46);

              case 49:
                return _context5.abrupt("return", globals.HOMES);

              case 50:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[29, 43, 46, 49]]);
      }));

      return function getHomes() {
        return _ref7.apply(this, arguments);
      };
    }();
    var _castR = function _castR(cast) {
      return CASTS[cast] === undefined ? cast : CASTS[cast];
    };
    var _loadIncludes = /*#__PURE__*/function () {
      var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(basePath, config) {
        var encoding,
            includes,
            _iterator5,
            _step5,
            alias,
            _iterator6,
            _step6,
            include,
            _args6 = arguments;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                encoding = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : "utf-8";
                includes = [];
                _iterator5 = _createForOfIteratorHelper(IMPORT_NAMES);

                try {
                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                    alias = _step5.value;
                    includes = config[alias] === undefined ? includes : config[alias];
                  }
                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }

                if (typeof includes === "string") {
                  includes = includes.split(";");
                }

                _iterator6 = _createForOfIteratorHelper(includes);
                _context6.prev = 6;

                _iterator6.s();

              case 8:
                if ((_step6 = _iterator6.n()).done) {
                  _context6.next = 14;
                  break;
                }

                include = _step6.value;
                _context6.next = 12;
                return loadFile(include, basePath, encoding);

              case 12:
                _context6.next = 8;
                break;

              case 14:
                _context6.next = 19;
                break;

              case 16:
                _context6.prev = 16;
                _context6.t0 = _context6["catch"](6);

                _iterator6.e(_context6.t0);

              case 19:
                _context6.prev = 19;

                _iterator6.f();

                return _context6.finish(19);

              case 22:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, null, [[6, 16, 19, 22]]);
      }));

      return function _loadIncludes(_x2, _x3) {
        return _ref8.apply(this, arguments);
      };
    }();
    var _isValid = function _isValid(key) {
      if (IMPORT_NAMES.includes(key)) return false;
      return true;
    };
    var _isDevel = function _isDevel() {
      return ["DEBUG"].includes(conf("LEVEL", "INFO"));
    };
    var _isSecure = function _isSecure() {
      return conf("SECURE", true, "bool");
    };

    /**
     * The map containing the various attribute alias between the normalized
     * manned and the Yonius manner.
     */
    var ALIAS = {
      context: "find_d",
      filters: "find_d",
      "filters[]": "find_d",
      filter_def: "find_d",
      filter_string: "find_s",
      filter_name: "find_n",
      filter_operator: "find_o",
      insensitive: "find_i",
      order: "sort",
      offset: "skip",
      start_record: "skip",
      number_records: "limit"
    };
    /**
     * The map associating the various find fields with their respective
     * types, note that in case a special conversion operation is required
     * the associated value may represent a conversion function instead.
     */

    var FIND_TYPES = {
      skip: function skip(v) {
        return parseInt(v);
      },
      limit: function limit(v) {
        return Math.max(0, parseInt(v));
      },
      find_s: function find_s(v) {
        return v;
      },
      find_d: function find_d(v) {
        return Array.isArray(v) ? v : [v];
      },
      find_i: function find_i(v) {
        return Boolean(v);
      },
      find_t: function find_t(v) {
        return v;
      },
      find_n: function find_n(v) {
        return v;
      },
      find_o: function find_o(v) {
        return v;
      },
      sort: function sort(v) {
        return _toSort(v);
      },
      meta: function meta(v) {
        return Boolean(v);
      },
      fields: function fields(v) {
        return v;
      }
    };
    /**
     * The map that defines the various default values for a series of
     * find related attributes.
     */

    var FIND_DEFAULTS = {
      limit: 10
    };
    /**
     * The map associating the normalized (text) way of representing sorting
     * with the current infra-structure number way of representing the same
     * information.
     */

    var SORT_MAP = {
      1: 1,
      "-1": -1,
      ascending: 1,
      descending: -1
    };
    var getObject = function getObject() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _options$alias = options.alias,
          alias = _options$alias === void 0 ? false : _options$alias,
          _options$page = options.page,
          page = _options$page === void 0 ? false : _options$page,
          _options$find = options.find,
          find = _options$find === void 0 ? false : _options$find,
          _options$norm = options.norm,
          norm = _options$norm === void 0 ? true : _options$norm;
      var result = params; // in case the alias flag is set tries to resolve the attribute alias and
      // in case the find types are set converts the find based attributes using
      // the currently defined mapping map

      if (alias) result = _resolveAlias(result);
      if (page) result = _pageTypes(result);

      if (find) {
        result = _findTypes(result);
        result = _findDefaults(result, options);
      } // in case the normalization flag is set runs the normalization of the
      // provided object so that sequences are properly handled as defined in
      // the specification (this allows multiple references)


      if (norm) result = _normParams(result); // returns the constructed object to the caller method this object
      // should be a structured representation of the data in the request

      return result;
    };

    var _resolveAlias = function _resolveAlias(params) {
      var result = {};
      Object.entries(params).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        result[ALIAS[key] || key] = value;
      });
      return result;
    };

    var _pageTypes = function _pageTypes(params) {
      var defaultSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;
      var result = Object.assign({}, params);
      var page = parseInt(params.page || 1);
      var size = parseInt(params.size || defaultSize);
      var offset = page - 1;
      result.skip = offset * size;
      result.limit = size;
      var sorter = params.sorter;
      var direction = params.direction || "descending";
      if (sorter) result.sort = "".concat(sorter, ":").concat(direction);
      return result;
    };

    var _toSort = function _toSort(value) {
      var values = value.split(":", 2);
      if (values.length === 1) values.push("descending");

      var _values = _slicedToArray(values, 2),
          name = _values[0],
          direction = _values[1];

      if (name === "default") return null;
      values[1] = SORT_MAP[direction] || 1;
      return [values];
    };

    var _findTypes = function _findTypes(params) {
      var result = {};
      Object.entries(params).forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            key = _ref4[0],
            value = _ref4[1];

        var converter = FIND_TYPES[key];
        var converted = converter ? converter(value) : value;
        result[key] = converted;
      });
      return result;
    };

    var _findDefaults = function _findDefaults(params) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var result = Object.assign({}, params);
      Object.entries(options).filter(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 1),
            key = _ref6[0];

        return FIND_TYPES[key];
      }).forEach(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
            key = _ref8[0],
            value = _ref8[1];

        result[key] = params[key] || value;
      });
      Object.entries(FIND_DEFAULTS).forEach(function (_ref9) {
        var _ref10 = _slicedToArray(_ref9, 2),
            key = _ref10[0],
            value = _ref10[1];

        result[key] = params[key] || value;
      });
      return result;
    };

    var _normParams = function _normParams(params) {
      var result = Object.assign({}, params); // iterates over all the key value association in the object,
      // trying to find the ones that refer sequences so that they
      // may be normalized

      for (var _i = 0, _Object$entries = Object.entries(params); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            key = _Object$entries$_i[0],
            value = _Object$entries$_i[1];

        // verifies if the current name references a sequence and
        // if that's not the case continues the loop trying to find
        // any other sequence based value
        if (!key.endsWith("[]")) {
          result[key] = value;
          continue;
        } // removes the extra sequence indication value


        var name = key.substring(0, key.length - 2); // in case the current value is not valid (empty) the object
        // is set with an empty list for the current iteration as this
        // is considered to be the default value

        if (!value) {
          result[name] = [];
          continue;
        } // retrieves the normalized and linearized list of leafs
        // for the current value and ten verifies the size of each
        // of its values and uses it to measure the number of
        // dictionary elements that are going to be contained in
        // the sequence to be "generated", then uses this (size)
        // value to pre-generate the complete set of dictionaries


        var leafs = _leafs(value);

        var _ref11 = leafs[0] || [null, []],
            _ref12 = _slicedToArray(_ref11, 2),
            values = _ref12[1];

        var list = values.map(function (_) {
          return {};
        }); // sets the list of generates dictionaries in the object for
        // the newly normalized name of structure

        result[name] = list; // iterates over the complete set of key value pairs in the
        // leafs list to gather the value into the various objects that
        // are contained in the sequence (normalization process)

        var _iterator = _createForOfIteratorHelper(leafs),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
                _name = _step$value[0],
                _value = _step$value[1];

            for (var index; index < list.length; index++) {
              var object = list[index];

              var nameList = _name.split(".");

              _setObject(object, nameList, _value[index]);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return result;
    };
    /**
     * Retrieves a list containing a series of tuples that each represent a
     * leaf of the current object structure. A leaf is the last element of an
     * object that is not a map, the other intermediary maps are considered to
     * be trunks and should be percolated recursively.
     * This is a recursive function that takes some memory for the construction
     * of the list, and so should be used with the proper care to avoid bottlenecks.
     *
     * @param {Object} params The object for which the leafs list structure is
     * meant to be retrieved.
     * @returns {Array} The list of leaf node tuples for the provided object,
     * as requested for each of the sequences.
     */


    var _leafs = function _leafs(params) {
      // the list that will hold the various leaf nodes "gathered" by
      // the current recursion function
      var result = []; // iterates over all the key and value relations in the object trying
      // to find the leaf nodes (no map nodes) creating a tuple of fqn
      // (fully qualified name) and value

      var _loop = function _loop() {
        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
            key = _Object$entries2$_i[0],
            value = _Object$entries2$_i[1];

        // retrieves the data type for the current value and validation
        // if it is a object or any other type in case it's an object a
        // new iteration step must be performed retrieving the leafs of
        // the value and then incrementing the name with the current prefix
        if (_typeof(value) === "object") {
          var leafs = _leafs(value).map(function (_ref13) {
            var _ref14 = _slicedToArray(_ref13, 2),
                name = _ref14[0],
                value = _ref14[1];

            return ["".concat(key, ".").concat(name), value];
          });

          result = Array.concat(result, leafs);
        } else {
          // otherwise this is a leaf node and so the leaf tuple node
          // must be constructed with the current value (properly validated
          // for sequence presence)
          result.push([key, Array.isArray(value) ? value : [value]]);
        }
      };

      for (var _i2 = 0, _Object$entries2 = Object.entries(params); _i2 < _Object$entries2.length; _i2++) {
        _loop();
      }

      return result;
    };
    /**
     * Sets a composite value in an object, allowing for dynamic setting of
     * random size key values.
     * This method is useful for situations where one wants to set a value
     * at a randomly defined depth inside an object without having to much
     * work with the creation of the inner dictionaries.
     *
     * @param {Object} object The target object that is going to be
     * changed and set with the target value.
     * @param {Array} nameList The list of names that defined the fully
     * qualified name to be used in the setting of the value
     * for example path.to.end will be a three size list containing each
     * of the partial names.
     * @param {Object} value The value that is going to be set in the
     * defined target of the object.
     */


    var _setObject = function _setObject(object, nameList, value) {
      // retrieves the first name in the names list this is the
      // value that is going to be used for the current iteration
      var _nameList$ = _toArray(nameList[0]),
          name = _nameList$[0],
          tail = _nameList$.slice(1); // in case the length of the current names list has reached
      // one this is the final iteration and so the value is set
      // at the current naming point


      if (nameList.length === 1) {
        object[name] = value;
      } else {
        // otherwise this is a "normal" step and so a new map must
        // be created/retrieved and the iteration step should be
        // performed on this new map as it's set on the current naming
        // place (recursion step)
        var map = object[name] || {};
        object[name] = map;

        _setObject(map, tail, value);
      }
    };

    var MixinBuilder = /*#__PURE__*/function () {
      function MixinBuilder(superclass) {
        _classCallCheck(this, MixinBuilder);

        this.superclass = superclass;
      }

      _createClass(MixinBuilder, [{
        key: "with",
        value: function _with() {
          for (var _len = arguments.length, mixins = new Array(_len), _key = 0; _key < _len; _key++) {
            mixins[_key] = arguments[_key];
          }

          return mixins.reduce(function (c, mixin) {
            return mixin(c);
          }, this.superclass);
        }
      }]);

      return MixinBuilder;
    }();
    var mix = function mix(superclass) {
      return new MixinBuilder(superclass);
    };

    var initMongo = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(mongoose, uri) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                mongoose.set("useNewUrlParser", true);
                mongoose.set("useFindAndModify", false);
                mongoose.set("useCreateIndex", true);
                mongoose.set("useUnifiedTopology", true);
                _context.next = 6;
                return mongoose.connect(uri, {
                  useNewUrlParser: true,
                  useUnifiedTopology: true
                });

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function initMongo(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();
    var destroyMongo = function destroyMongo(mongoose) {
      mongoose.disconnect();
    };

    var equal = function equal(first, second) {
      if (first === second) {
        return true;
      }

      if (typeof_(first) !== typeof_(second)) {
        return false;
      }

      if (isPrimitive(first) && isPrimitive(second)) {
        return first === second;
      }

      if (first instanceof Date && second instanceof Date) {
        return first === second;
      }

      if (Object.keys(first).length !== Object.keys(second).length) {
        return false;
      }

      for (var key in first) {
        if (!(key in second)) return false;
        if (!equal(first[key], second[key])) return false;
      }

      return true;
    };
    var isPrimitive = function isPrimitive(object) {
      return object !== Object(object);
    };
    var typeof_ = function typeof_(object) {
      if (object === null) return "null";
      if (Array.isArray(object)) return "array";
      return _typeof(object);
    };

    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    var escapeStringRegexp = function escapeStringRegexp(string) {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }

      return string.replace(matchOperatorsRegex, "\\$&");
    };

    /* The default minimum value meaning that this is the
    maximum value that one integer value may have for the
    size rounding operation to be performed */
    var DEFAULT_MINIMUM = 1024;
    /* The default number of places (digits) that are going
    to be used for the string representation in the round
    based conversion of size units to be performed */

    var DEFAULT_PLACES = 3;
    /* The size unit coefficient as an integer value, this is
    going to be used in each of the size steps as divisor */

    var SIZE_UNIT_COEFFICIENT = 1024;
    /* The simplified size units list that contains the complete set of
    units indexed by the depth they represent */

    var SIZE_UNITS_LIST_S = ["B", "K", "M", "G", "T", "P", "E", "Z", "Y"];
    /* The size units list that contains the complete set of
    units indexed by the depth they represent */

    var SIZE_UNITS_LIST = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
    var sizeRoundUnit = function sizeRoundUnit(sizeValue) {
      var minimum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_MINIMUM;
      var places = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_PLACES;
      var reduce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var space = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var justify = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      var simplified = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      var depth = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;

      // in case the current size value is acceptable (less than
      // the minimum) this is the final iteration and the final
      // string representation is going to be created
      if (sizeValue < minimum) {
        // calculates the maximum size of the string that is going
        // to represent the base size value as the number of places
        // plus one (representing the decimal separator character)
        var sizeS = places + 1; // calculates the target number of decimal places taking
        // into account the size (in digits) of the current size
        // value, this may never be a negative number

        var logValue = sizeValue && Math.log10(sizeValue);
        var digits = Math.trunc(logValue) + 1;
        places = places - digits;
        places = places > 0 ? places : 0; // rounds the size value, then converts the rounded
        // size value into a string based representation

        var sizeValueS = sizeValue.toFixed(places); // forces the reduce flag when the depth is zero, meaning
        // that an integer value will never be decimal, this is
        // required to avoid strange results for depth zero

        reduce = reduce || depth === 0; // in case the dot value is not present in the size value
        // string adds it to the end otherwise an issue may occur
        // while removing extra padding characters for reduce

        if (reduce && !sizeValueS.includes(".")) sizeValueS += "."; // strips the value from zero appended to the right and
        // then strips the value also from a possible decimal
        // point value that may be included in it, this is only
        // performed in case the reduce flag is enabled

        if (reduce) sizeValueS = sizeValueS.replace(/0+$/, "");
        if (reduce) sizeValueS = sizeValueS.replace(/\.$/, ""); // in case the justify flag is set runs the justification
        // process on the size value taking into account the maximum
        // size of the associated size string

        if (justify) sizeValueS = _rjust(sizeValueS, sizeS); // retrieves the size unit (string mode) for the current
        // depth according to the provided map

        var sizeUnit;
        if (simplified) sizeUnit = SIZE_UNITS_LIST_S[depth];else sizeUnit = SIZE_UNITS_LIST[depth]; // retrieves the appropriate separator based
        // on the value of the space flag

        var separator = space && " " || ""; // creates the size value string appending the rounded
        // size value string and the size unit and returns it
        // to the caller method as the size value string

        var sizeValueString = sizeValueS + separator + sizeUnit;
        return sizeValueString;
      } // otherwise the value is not acceptable and a new iteration
      // must be ran with one less depth of size value
      else {
        // re-calculates the new size value, increments the depth
        // and runs the size round unit again with the new values
        var newSizeValue = parseFloat(sizeValue) / SIZE_UNIT_COEFFICIENT;
        var newDepth = depth + 1;
        return sizeRoundUnit(newSizeValue, minimum, places, reduce, space, justify, simplified, newDepth);
      }
    };

    var _rjust = function _rjust(str, length) {
      var lengthToFill = length - str.length;
      return lengthToFill <= 0 ? str : " ".repeat(lengthToFill) + str;
    };

    var camelToUnderscore = function camelToUnderscore(value) {
      var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "_";
      if (!value) return value;
      return value.replace(/\.?([A-Z])/g, function (x, y) {
        return separator + y.toLowerCase();
      }).replace(RegExp("^" + separator), "");
    };
    var underscoreToCamel = function underscoreToCamel(value) {
      var lower = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "_";
      if (!value) return value;
      var slices = value.split(separator);
      return slices.map(function (s, i) {
        if (i === 0 && lower) return s.charAt(0).toLowerCase() + s.slice(1);
        return s.charAt(0).toUpperCase() + s.slice(1);
      }).join("");
    };

    /**
     * Encodes the multiple values as and encoded URI component, the
     * values can be wither defined as an array (order is preserved)
     * or as an object (where sequence order is not preserved).
     *
     * The value of each item can be either a primitive type or a sequence
     * in case it's of sequence the values are going to be encoded as
     * multiple parameters separated by the '&' character.
     *
     * @param {(Array|Object[])} values The values to be encoded as an
     * URI component (like GET params).
     * @returns {String} A string with the query encoded values.
     */

    var urlEncode = function urlEncode(values) {
      // constructs the parts array that is going to
      // store the multiple and values
      var parts = []; // in case the provided value is not an array
      // then assumes it's an object and retrieve entries

      if (!Array.isArray(values)) {
        values = Object.entries(values);
      } // iterates over the complete set of pairs available
      // from the key value pairs to be able to encode them
      // properly, notice that the values themselves can be
      // sequences allowing multiple repetition of key


      values.forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        if (!Array.isArray(value)) {
          value = [value];
        }

        var keyEncoded = encodeURIComponent(key);
        value.forEach(function (_value) {
          if (_value === undefined || _value === null) {
            return;
          }

          var valueEncoded = encodeURIComponent(_value);
          parts.push("".concat(keyEncoded, "=").concat(valueEncoded));
        });
      }); // joins the complete set of parts with the and
      // separator and then returns the final string value

      return parts.join("&");
    };
    var absoluteUrl = function absoluteUrl(path) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "BASE_URL";
      var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var baseUrl = conf(name, fallback);
      if (!baseUrl) return null;
      return "".concat(baseUrl).concat(path);
    };

    var YoniusError = /*#__PURE__*/function (_Error) {
      _inherits(YoniusError, _Error);

      var _super = _createSuper(YoniusError);

      function YoniusError(message) {
        var _this;

        var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;

        _classCallCheck(this, YoniusError);

        _this = _super.call(this, message);
        _this.name = _this.constructor.name;
        _this.code = code;
        return _this;
      }

      _createClass(YoniusError, [{
        key: "isClient",
        get: function get() {
          return Math.floor(this.code / 100) === 4;
        }
      }, {
        key: "isServer",
        get: function get() {
          return Math.floor(this.code / 100) === 5;
        }
      }]);

      return YoniusError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));
    var OperationalError = /*#__PURE__*/function (_YoniusError) {
      _inherits(OperationalError, _YoniusError);

      var _super2 = _createSuper(OperationalError);

      function OperationalError() {
        var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Operational error";
        var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;

        _classCallCheck(this, OperationalError);

        return _super2.call(this, message, code);
      }

      return _createClass(OperationalError);
    }(YoniusError);
    var NotFoundError = /*#__PURE__*/function (_OperationalError) {
      _inherits(NotFoundError, _OperationalError);

      var _super3 = _createSuper(NotFoundError);

      function NotFoundError() {
        var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Not found";
        var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 404;

        _classCallCheck(this, NotFoundError);

        return _super3.call(this, message, code);
      }

      return _createClass(NotFoundError);
    }(OperationalError);
    var NotImplementedError = /*#__PURE__*/function (_OperationalError2) {
      _inherits(NotImplementedError, _OperationalError2);

      var _super4 = _createSuper(NotImplementedError);

      function NotImplementedError() {
        var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Not implemented";
        var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 501;

        _classCallCheck(this, NotImplementedError);

        return _super4.call(this, message, code);
      }

      return _createClass(NotImplementedError);
    }(OperationalError);
    var ValidationError = /*#__PURE__*/function (_OperationalError3) {
      _inherits(ValidationError, _OperationalError3);

      var _super5 = _createSuper(ValidationError);

      function ValidationError() {
        var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Validation of submitted data failed";
        var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;

        _classCallCheck(this, ValidationError);

        return _super5.call(this, message, code);
      }

      return _createClass(ValidationError);
    }(OperationalError);
    var AttributeError = /*#__PURE__*/function (_YoniusError2) {
      _inherits(AttributeError, _YoniusError2);

      var _super6 = _createSuper(AttributeError);

      function AttributeError() {
        var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Attribute not found";

        _classCallCheck(this, AttributeError);

        return _super6.call(this, message);
      }

      return _createClass(AttributeError);
    }(YoniusError);

    /**
     * The simple regex used to validate
     * if the provided value is a "simple" one meaning
     * that it may be used safely for URL parts
     */

    var SIMPLE_REGEX = /^[\:\.\s\w-]+$/;
    /**
     * The email regex used to validate
     * if the provided value is in fact an email
     */

    var EMAIL_REGEX = /^[\w\d\._%+-]+@[\w\d\.\-]+$/;
    /**
     * The URL regex used to validate
     * if the provided value is in fact an URL/URI
     */

    var URL_REGEX = /^\w+\:\/\/([^@]+\:[^@]+@)?[^\:\/\?#]+(\:\d+)?(\/[^\?#]+)*\/?(\?[^#]*)?(#.*)?$/;
    var eq = function eq(valueC) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Must be equal to %{1}";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
      };

      return validation;
    };
    var gt = function gt(valueC) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Must be greater than %{1}";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value > valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
      };

      return validation;
    };
    var gte = function gte(valueC) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Must be greater than or equal to %{1}";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value >= valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
      };

      return validation;
    };
    var notEmpty = function notEmpty() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Value is empty";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value.length) return true;
        throw new ValidationError(message);
      };

      return validation;
    };
    var isIn = function isIn(valueC) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Value must be one of: %{1}";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (valueC.includes(value)) return true;
        throw new ValidationError(message.replace("%{1}", valueC.join(", ")));
      };

      return validation;
    };
    var isUpper = function isUpper() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Value contains lower cased characters";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value === value.toUpperCase()) return true;
        throw new ValidationError(message);
      };

      return validation;
    };
    var isLower = function isLower() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Value contains upper cased characters";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value === value.toLowerCase()) return true;
        throw new ValidationError(message);
      };

      return validation;
    };
    var isSimple = function isSimple() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Value contains invalid characters";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value.match(SIMPLE_REGEX)) return true;
        throw new ValidationError(message);
      };

      return validation;
    };
    var isEmail = function isEmail() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Value is not a valid email";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value.match(EMAIL_REGEX)) return true;
        throw new ValidationError(message);
      };

      return validation;
    };
    var isUrl = function isUrl() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Value is not a valid URL";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value.match(URL_REGEX)) return true;
        throw new ValidationError(message);
      };

      return validation;
    };
    var isRegex = function isRegex(regex) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Value has incorrect format";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value.match(new RegExp(regex))) return true;
        throw new ValidationError(message);
      };

      return validation;
    };
    var stringGt = function stringGt(valueC) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Must be larger than %{1} characters";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value.length > valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
      };

      return validation;
    };
    var stringLt = function stringLt(valueC) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Must be smaller than %{1} characters";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value.length < valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
      };

      return validation;
    };
    var stringEq = function stringEq(valueC) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Must be exactly %{1} characters";

      var validation = function validation(value, ctx) {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value.length === valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
      };

      return validation;
    };
    var all = function all(validation) {
      var _validation = function _validation(sequence, ctx) {
        if (sequence === undefined) return true;
        if (sequence === null) return true;

        var _iterator = _createForOfIteratorHelper(sequence),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var value = _step.value;
            validation(value, ctx);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return true;
      };

      return _validation;
    };

    var fetch$1 = fetch;

    var AUTH_ERRORS = [401, 403, 440, 499];
    var API = /*#__PURE__*/function (_Observable) {
      _inherits(API, _Observable);

      var _super = _createSuper(API);

      function API() {
        var _this;

        var kwargs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, API);

        _this = _super.call(this);
        _this.kwargs = kwargs;
        return _this;
      }

      _createClass(API, [{
        key: "build",
        value: function () {
          var _build = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(method, url) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:

                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function build(_x, _x2) {
            return _build.apply(this, arguments);
          }

          return build;
        }()
      }, {
        key: "authCallback",
        value: function () {
          var _authCallback = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params, headers) {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function authCallback(_x3, _x4) {
            return _authCallback.apply(this, arguments);
          }

          return authCallback;
        }()
      }, {
        key: "get",
        value: function () {
          var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(url) {
            var options,
                result,
                _args3 = arguments;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
                    _context3.next = 3;
                    return this.methodBasic("GET", url, options);

                  case 3:
                    result = _context3.sent;
                    return _context3.abrupt("return", result);

                  case 5:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function get(_x5) {
            return _get.apply(this, arguments);
          }

          return get;
        }()
      }, {
        key: "post",
        value: function () {
          var _post = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(url) {
            var options,
                result,
                _args4 = arguments;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
                    _context4.next = 3;
                    return this.methodPayload("POST", url, options);

                  case 3:
                    result = _context4.sent;
                    return _context4.abrupt("return", result);

                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function post(_x6) {
            return _post.apply(this, arguments);
          }

          return post;
        }()
      }, {
        key: "put",
        value: function () {
          var _put = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(url) {
            var options,
                result,
                _args5 = arguments;
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
                    _context5.next = 3;
                    return this.methodPayload("PUT", url, options);

                  case 3:
                    result = _context5.sent;
                    return _context5.abrupt("return", result);

                  case 5:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function put(_x7) {
            return _put.apply(this, arguments);
          }

          return put;
        }()
      }, {
        key: "delete",
        value: function () {
          var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(url) {
            var options,
                result,
                _args6 = arguments;
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
                    _context6.next = 3;
                    return this.methodBasic("DELETE", url, options);

                  case 3:
                    result = _context6.sent;
                    return _context6.abrupt("return", result);

                  case 5:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function _delete(_x8) {
            return _delete2.apply(this, arguments);
          }

          return _delete;
        }()
      }, {
        key: "patch",
        value: function () {
          var _patch = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(url) {
            var options,
                result,
                _args7 = arguments;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
                    _context7.next = 3;
                    return this.methodPayload("PATCH", url, options);

                  case 3:
                    result = _context7.sent;
                    return _context7.abrupt("return", result);

                  case 5:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function patch(_x9) {
            return _patch.apply(this, arguments);
          }

          return patch;
        }()
      }, {
        key: "options",
        value: function () {
          var _options2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(url) {
            var _options,
                result,
                _args8 = arguments;

            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                    _context8.next = 3;
                    return this.methodBasic("OPTIONS", url, _options);

                  case 3:
                    result = _context8.sent;
                    return _context8.abrupt("return", result);

                  case 5:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));

          function options(_x10) {
            return _options2.apply(this, arguments);
          }

          return options;
        }()
      }, {
        key: "methodBasic",
        value: function () {
          var _methodBasic2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(method, url) {
            var options,
                _args9 = arguments;
            return regeneratorRuntime.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    options = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : {};
                    options.params = options.params !== undefined ? options.params : {};
                    options.headers = options.headers !== undefined ? options.headers : {};
                    _context9.prev = 3;
                    _context9.next = 6;
                    return this._methodBasic(method, url, options);

                  case 6:
                    return _context9.abrupt("return", _context9.sent);

                  case 9:
                    _context9.prev = 9;
                    _context9.t0 = _context9["catch"](3);

                    if (!AUTH_ERRORS.includes(_context9.t0.code)) {
                      _context9.next = 19;
                      break;
                    }

                    _context9.next = 14;
                    return this.authCallback(options.params, options.headers);

                  case 14:
                    _context9.next = 16;
                    return this._methodBasic(method, url, options);

                  case 16:
                    return _context9.abrupt("return", _context9.sent);

                  case 19:
                    throw _context9.t0;

                  case 20:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this, [[3, 9]]);
          }));

          function methodBasic(_x11, _x12) {
            return _methodBasic2.apply(this, arguments);
          }

          return methodBasic;
        }()
      }, {
        key: "methodPayload",
        value: function () {
          var _methodPayload2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(method, url) {
            var options,
                _args10 = arguments;
            return regeneratorRuntime.wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    options = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : {};
                    options.params = options.params !== undefined ? options.params : {};
                    options.headers = options.headers !== undefined ? options.headers : {};
                    _context10.prev = 3;
                    _context10.next = 6;
                    return this._methodPayload(method, url, options);

                  case 6:
                    return _context10.abrupt("return", _context10.sent);

                  case 9:
                    _context10.prev = 9;
                    _context10.t0 = _context10["catch"](3);

                    if (!AUTH_ERRORS.includes(_context10.t0.code)) {
                      _context10.next = 19;
                      break;
                    }

                    _context10.next = 14;
                    return this.authCallback(options.params, options.headers);

                  case 14:
                    _context10.next = 16;
                    return this._methodPayload(method, url, options);

                  case 16:
                    return _context10.abrupt("return", _context10.sent);

                  case 19:
                    throw _context10.t0;

                  case 20:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this, [[3, 9]]);
          }));

          function methodPayload(_x13, _x14) {
            return _methodPayload2.apply(this, arguments);
          }

          return methodPayload;
        }()
      }, {
        key: "_methodBasic",
        value: function () {
          var _methodBasic3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(method, url) {
            var options,
                params,
                headers,
                kwargs,
                handle,
                getAgent,
                query,
                response,
                result,
                _args11 = arguments;
            return regeneratorRuntime.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    options = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : {};
                    params = options.params !== undefined ? options.params : {};
                    headers = options.headers !== undefined ? options.headers : {};
                    kwargs = options.kwargs !== undefined ? options.kwargs : {};
                    handle = options.handle !== undefined ? options.handle : true;
                    getAgent = options.getAgent !== undefined ? options.getAgent : undefined;
                    _context11.next = 8;
                    return this.build(method, url, {
                      params: params,
                      headers: headers,
                      kwargs: kwargs
                    });

                  case 8:
                    query = urlEncode(params || {});
                    if (query) url += url.includes("?") ? "&" + query : "?" + query;
                    _context11.next = 12;
                    return fetch$1(url, {
                      method: method,
                      headers: headers || {},
                      agent: getAgent || globals.getAgent || undefined
                    });

                  case 12:
                    response = _context11.sent;

                    if (!handle) {
                      _context11.next = 19;
                      break;
                    }

                    _context11.next = 16;
                    return this._handleResponse(response);

                  case 16:
                    _context11.t0 = _context11.sent;
                    _context11.next = 20;
                    break;

                  case 19:
                    _context11.t0 = response;

                  case 20:
                    result = _context11.t0;
                    return _context11.abrupt("return", result);

                  case 22:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));

          function _methodBasic(_x15, _x16) {
            return _methodBasic3.apply(this, arguments);
          }

          return _methodBasic;
        }()
      }, {
        key: "_methodPayload",
        value: function () {
          var _methodPayload3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(method, url) {
            var options,
                params,
                headers,
                data,
                dataJ,
                dataM,
                mime,
                kwargs,
                handle,
                getAgent,
                query,
                _this$_encodeMultipar,
                _this$_encodeMultipar2,
                response,
                result,
                _args12 = arguments;

            return regeneratorRuntime.wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    options = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : {};
                    params = options.params !== undefined ? options.params : {};
                    headers = options.headers !== undefined ? options.headers : {};
                    data = options.data !== undefined ? options.data : null;
                    dataJ = options.dataJ !== undefined ? options.dataJ : null;
                    dataM = options.dataM !== undefined ? options.dataM : null;
                    mime = options.mime !== undefined ? options.mime : null;
                    kwargs = options.kwargs !== undefined ? options.kwargs : {};
                    handle = options.handle !== undefined ? options.handle : true;
                    getAgent = options.getAgent !== undefined ? options.getAgent : undefined;
                    _context12.next = 12;
                    return this.build(method, url, {
                      params: params,
                      headers: headers,
                      data: data,
                      dataJ: dataJ,
                      dataM: dataM,
                      mime: mime,
                      kwargs: kwargs
                    });

                  case 12:
                    query = urlEncode(params || {});

                    if (data !== null) {
                      if (query) url += url.includes("?") ? "&" + query : "?" + query;
                    } else if (dataJ !== null) {
                      data = JSON.stringify(dataJ);
                      if (query) url += url.includes("?") ? "&" + query : "?" + query;
                      mime = mime || "application/json";
                    } else if (dataM !== null) {
                      if (query) url += url.includes("?") ? "&" + query : "?" + query;
                      _this$_encodeMultipar = this._encodeMultipart(dataM, mime, true);
                      _this$_encodeMultipar2 = _slicedToArray(_this$_encodeMultipar, 2);
                      mime = _this$_encodeMultipar2[0];
                      data = _this$_encodeMultipar2[1];
                    } else if (query) {
                      data = query;
                      mime = mime || "application/x-www-form-urlencoded";
                    }

                    headers = Object.assign({}, headers);
                    if (mime) headers["Content-Type"] = mime;
                    _context12.next = 18;
                    return fetch$1(url, {
                      method: method,
                      headers: headers || {},
                      body: data,
                      agent: getAgent || global.getAgent || undefined
                    });

                  case 18:
                    response = _context12.sent;

                    if (!handle) {
                      _context12.next = 25;
                      break;
                    }

                    _context12.next = 22;
                    return this._handleResponse(response);

                  case 22:
                    _context12.t0 = _context12.sent;
                    _context12.next = 26;
                    break;

                  case 25:
                    _context12.t0 = response;

                  case 26:
                    result = _context12.t0;
                    return _context12.abrupt("return", result);

                  case 28:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this);
          }));

          function _methodPayload(_x17, _x18) {
            return _methodPayload3.apply(this, arguments);
          }

          return _methodPayload;
        }()
      }, {
        key: "_handleResponse",
        value: function () {
          var _handleResponse2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(response) {
            var errorMessage,
                result,
                _args13 = arguments;
            return regeneratorRuntime.wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    errorMessage = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : "Problem in request";
                    result = null;

                    if (!(response.headers.get("content-type") && response.headers.get("content-type").toLowerCase().startsWith("application/json"))) {
                      _context13.next = 8;
                      break;
                    }

                    _context13.next = 5;
                    return response.json();

                  case 5:
                    result = _context13.sent;
                    _context13.next = 17;
                    break;

                  case 8:
                    if (!(response.headers.get("content-type") && response.headers.get("content-type").toLowerCase().startsWith("text/"))) {
                      _context13.next = 14;
                      break;
                    }

                    _context13.next = 11;
                    return response.text();

                  case 11:
                    result = _context13.sent;
                    _context13.next = 17;
                    break;

                  case 14:
                    _context13.next = 16;
                    return response.blob();

                  case 16:
                    result = _context13.sent;

                  case 17:
                    verify(response.ok, result.error || errorMessage, response.status || 500);
                    return _context13.abrupt("return", result);

                  case 19:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13);
          }));

          function _handleResponse(_x19) {
            return _handleResponse2.apply(this, arguments);
          }

          return _handleResponse;
        }()
      }, {
        key: "_encodeMultipart",
        value: function _encodeMultipart(fields) {
          var mime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var doseq = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          mime = mime || "multipart/form-data";

          var boundary = this._createBoundary(fields, undefined, doseq);

          var encoder = new TextEncoder("utf-8");
          var buffer = [];

          for (var _i = 0, _Object$entries = Object.entries(fields); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                key = _Object$entries$_i[0],
                values = _Object$entries$_i[1];

            var isList = doseq && Array.isArray(values);
            values = isList ? values : [values];

            var _iterator = _createForOfIteratorHelper(values),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var value = _step.value;
                if (value === null) continue;
                var header = void 0;

                if (_typeof(value) === "object" && !(value instanceof Array) && value.constructor !== Uint8Array) {
                  var headerL = [];
                  var data = null;

                  for (var _i2 = 0, _Object$entries2 = Object.entries(value); _i2 < _Object$entries2.length; _i2++) {
                    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
                        _key = _Object$entries2$_i[0],
                        item = _Object$entries2$_i[1];

                    if (_key === "data") data = item;else headerL.push("".concat(_key, ": ").concat(item));
                  }

                  value = data;
                  header = headerL.join("\r\n");
                } else if (value instanceof Array) {
                  var name = null;
                  var contents = null;
                  var contentTypeD = null;

                  if (value.length === 2) {
                    var _value = value;

                    var _value2 = _slicedToArray(_value, 2);

                    name = _value2[0];
                    contents = _value2[1];
                  } else {
                    var _value3 = value;

                    var _value4 = _slicedToArray(_value3, 3);

                    name = _value4[0];
                    contentTypeD = _value4[1];
                    contents = _value4[2];
                  }

                  header = "Content-Disposition: form-data; name=\"".concat(key, "\"; filename=\"").concat(name, "\"");
                  if (contentTypeD) header += "\r\nContent-Type: ".concat(contentTypeD);
                  value = contents;
                } else {
                  header = "Content-Disposition: form-data; name=\"".concat(key, "\"");
                  value = value.constructor === Uint8Array ? value : encoder.encode(value);
                }

                buffer.push(encoder.encode("--" + boundary + "\r\n"));
                buffer.push(encoder.encode(header + "\r\n"));
                buffer.push(encoder.encode("\r\n"));
                buffer.push(value);
                buffer.push(encoder.encode("\r\n"));
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }

          buffer.push(encoder.encode("--" + boundary + "--\r\n"));
          buffer.push(encoder.encode("\r\n"));

          var body = this._joinBuffer(buffer);

          var contentType = "".concat(mime, "; boundary=").concat(boundary);
          return [contentType, body];
        }
      }, {
        key: "_createBoundary",
        value: function _createBoundary(fields) {
          return "Vq2xNWWHbmWYF644q9bC5T2ALtj5CynryArNQRXGYsfm37vwFKMNsqPBrpPeprFs";
        }
      }, {
        key: "_joinBuffer",
        value: function _joinBuffer(bufferArray) {
          var bufferSize = bufferArray.map(function (item) {
            return item.byteLength;
          }).reduce(function (a, v) {
            return a + v;
          }, 0);
          var buffer = new Uint8Array(bufferSize);
          var offset = 0;

          var _iterator2 = _createForOfIteratorHelper(bufferArray),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var item = _step2.value;
              buffer.set(item, offset);
              offset += item.byteLength;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          return buffer;
        }
      }]);

      return API;
    }(Observable);
    var buildGetAgent = function buildGetAgent(AgentHttp, AgentHttps) {
      var set = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var httpAgent = new AgentHttp({
        keepAlive: options.keepAlive === undefined ? true : options.keepAlive,
        keepAliveMsecs: options.keepAliveMsecs || 120000,
        timeout: options.timeout || 60000,
        scheduling: options.scheduling || "fifo"
      });
      var httpsAgent = new AgentHttps({
        keepAlive: options.keepAlive === undefined ? true : options.keepAlive,
        keepAliveMsecs: options.keepAliveMsecs || 120000,
        timeout: options.timeout || 60000,
        scheduling: options.scheduling || "fifo"
      });

      var getAgent = function getAgent(parsedURL) {
        return parsedURL.protocol === "http:" ? httpAgent : httpsAgent;
      };

      if (set) globals.getAgent = getAgent;
      return getAgent;
    };
    /**
     * Tries to patch the global environment with a proper `getAgent`
     * function that can handle HTTP and HTTP connection polling.
     *
     * This can only be performed in a node.js environment (uses `require`).
     *
     * @returns {Function} The `getAgent` function that has just been
     * built and set in the globals.
     */

    var patchAgent = function patchAgent() {
      if (typeof require !== "function") return;
      if (globals.getAgent) return;
      var http, https;

      try {
        http = require("http");
        https = require("https");
      } catch (err) {
        return;
      }

      if (!http || !https) return;
      if (!http.Agent || !https.Agent) return;
      return buildGetAgent(http.Agent, https.Agent, true);
    }; // patches the global agent if possible, using the
    // global dynamic require statements

    patchAgent();

    var OAuthAPI = /*#__PURE__*/function (_API) {
      _inherits(OAuthAPI, _API);

      var _super = _createSuper(OAuthAPI);

      function OAuthAPI() {
        _classCallCheck(this, OAuthAPI);

        return _super.apply(this, arguments);
      }

      return _createClass(OAuthAPI);
    }(API);

    var OAuth1API = /*#__PURE__*/function (_OAuthAPI) {
      _inherits(OAuth1API, _OAuthAPI);

      var _super = _createSuper(OAuth1API);

      function OAuth1API() {
        _classCallCheck(this, OAuth1API);

        return _super.apply(this, arguments);
      }

      return _createClass(OAuth1API);
    }(OAuthAPI);

    var OAuth2API = /*#__PURE__*/function (_OAuthAPI) {
      _inherits(OAuth2API, _OAuthAPI);

      var _super = _createSuper(OAuth2API);

      function OAuth2API() {
        var _this;

        var kwargs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, OAuth2API);

        _this = _super.call(this, kwargs);
        _this.accessToken = null;
        return _this;
      }

      _createClass(OAuth2API, [{
        key: "build",
        value: function () {
          var _build = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(method, url) {
            var options,
                params,
                headers,
                kwargs,
                token,
                _args = arguments;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
                    _context.next = 3;
                    return _get(_getPrototypeOf(OAuth2API.prototype), "build", this).call(this, method, url, options);

                  case 3:
                    params = options.params !== undefined ? options.params : {};
                    headers = options.headers !== undefined ? options.headers : {};
                    kwargs = options.kwargs !== undefined ? options.kwargs : {};
                    token = kwargs.token === undefined ? this.tokenDefault : kwargs.token;
                    delete kwargs.token;

                    if (token && this.oauthTypes.includes("param")) {
                      params[this.oauthParam] = this.getAccessToken();
                    }

                    if (token && this.oauthTypes.includes("header")) {
                      headers.Authorization = "Bearer ".concat(this.getAccessToken());
                    }

                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function build(_x, _x2) {
            return _build.apply(this, arguments);
          }

          return build;
        }()
      }, {
        key: "getAccessToken",
        value: function getAccessToken() {
          if (this.accessToken) return this.accessToken;
          throw new Error("No access token found must re-authorize");
        }
      }, {
        key: "oauthTypes",
        get: function get() {
          return ["param", "header"];
        }
      }, {
        key: "oauthParam",
        get: function get() {
          return "access_token";
        }
      }, {
        key: "tokenDefault",
        get: function get() {
          return true;
        }
      }]);

      return OAuth2API;
    }(OAuthAPI);

    /**
     * Ensures that the current "session" context contains the
     * requested ACL token as valid.
     *
     * In case the validation fails an exception is raised
     * indicating the auth validation error.
     *
     * @param {String} token The ACL token to ensure permission,
     * the logged user should be allowed to id.
     * @param {Object} ctx The context object to be used in
     * the session basic ACL retrieval, should contain proper
     * injected methods for retrieval (eg: `getAcl`).
     */

    var ensurePermissions = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(token, ctx) {
        var acl, tokens;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!ctx.getAcl) {
                  _context.next = 6;
                  break;
                }

                _context.next = 3;
                return ctx.getAcl(ctx);

              case 3:
                _context.t0 = _context.sent;
                _context.next = 7;
                break;

              case 6:
                _context.t0 = {};

              case 7:
                acl = _context.t0;
                tokens = toTokensM(acl); // in case the permission validation test is not positive
                // then an exception should be raised indicating the issue

                if (hasPermission(token, tokens)) {
                  _context.next = 11;
                  break;
                }

                throw new OperationalError("You don't have authorization to access this resource", 401);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function ensurePermissions(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();
    /**
     * Converts the provided list of token strings separated by dots
     * into a map based representation on an hierarchical structure.
     *
     * @param {Array} tokens A linear array of tokens to convert into
     * an hierarchical representation.
     * @returns {Object} The map containing the hierarchy of tokens
     * for the provided linear string based sequence of tokens.
     */

    var toTokensM = function toTokensM(tokens) {
      var tokensM = {};
      if (tokens === undefined) return tokensM;
      if (tokens === null) return tokensM;
      if (!Array.isArray(tokens)) return tokensM;

      var _iterator = _createForOfIteratorHelper(tokens),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var token = _step.value;
          var tokensC = tokensM;
          var tokenL = token.split(".");
          var head = tokenL.slice(0, tokenL.length - 1);
          var tail = tokenL[tokenL.length - 1];

          var _iterator2 = _createForOfIteratorHelper(head),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var tokenP = _step2.value;
              var current = tokensC[tokenP] || {};
              var isDict = _typeof(current) === "object";
              if (!isDict) current = {
                _: current
              };
              tokensC[tokenP] = current;
              tokensC = current;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          var leaf = tokensC[tail] || null;
          if (leaf && _typeof(leaf) === "object") leaf._ = true;else tokensC[tail] = true;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return tokensM;
    };
    var hasPermission = function hasPermission(token) {
      var tokensM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (!token) return true;
      if (tokensM === undefined || tokensM === null) return false;
      var tokenL = token.split(".");

      var _iterator3 = _createForOfIteratorHelper(tokenL),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var tokenP = _step3.value;
          if (_typeof(tokensM) !== "object") return false;
          if (tokensM["*"]) return true;
          if (tokensM[tokenP] === undefined) return false;
          tokensM = tokensM[tokenP];
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      var isDict = _typeof(tokensM) === "object";
      var result = isDict ? tokensM._ || false : tokensM;
      return Boolean(result);
    };

    var REGISTRY = {};
    var load = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return load$1();

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function load() {
        return _ref.apply(this, arguments);
      };
    }();
    var unload = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function unload() {
        return _ref2.apply(this, arguments);
      };
    }();
    var register = function register(name, value) {
      REGISTRY[name] = value;
    };
    var unregister = function unregister(name) {
      delete REGISTRY[name];
    };
    var request = function request(name) {
      if (REGISTRY[name] === undefined) {
        throw new OperationalError("Name '".concat(name, "' not found in registry"));
      }

      return REGISTRY[name];
    };

    var FileTuple = /*#__PURE__*/function (_Array) {
      _inherits(FileTuple, _Array);

      var _super = _createSuper(FileTuple);

      function FileTuple() {
        _classCallCheck(this, FileTuple);

        return _super.apply(this, arguments);
      }

      _createClass(FileTuple, [{
        key: "name",
        get: function get() {
          return this[0];
        }
      }, {
        key: "mime",
        get: function get() {
          return this[1];
        }
      }, {
        key: "data",
        get: function get() {
          return this[2];
        }
      }], [{
        key: "fromData",
        value: function fromData(data) {
          var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var mime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var fileTuple = new this(name, mime, data);
          return fileTuple;
        }
      }, {
        key: "fromString",
        value: function fromString(dataString) {
          var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var mime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
              _ref$encoding = _ref.encoding,
              encoding = _ref$encoding === void 0 ? "utf-8" : _ref$encoding;

          var data = new TextEncoder(encoding).encode(dataString);
          return this.fromData(data, name, mime);
        }
      }, {
        key: "fromArrayBuffer",
        value: function fromArrayBuffer(arrayBuffer) {
          var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var mime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var buffer = Buffer.from(arrayBuffer);
          return this.fromData(buffer, name, mime);
        }
      }, {
        key: "fromBlob",
        value: function () {
          var _fromBlob = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(blob) {
            var name,
                mime,
                arrayBuffer,
                _args = arguments;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    name = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                    mime = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                    _context.next = 4;
                    return blob.arrayBuffer();

                  case 4:
                    arrayBuffer = _context.sent;
                    return _context.abrupt("return", this.fromArrayBuffer(arrayBuffer, name, mime));

                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function fromBlob(_x) {
            return _fromBlob.apply(this, arguments);
          }

          return fromBlob;
        }()
      }]);

      return FileTuple;
    }( /*#__PURE__*/_wrapNativeSuper(Array));

    var AbstractType = /*#__PURE__*/function () {
      function AbstractType() {
        _classCallCheck(this, AbstractType);
      }

      _createClass(AbstractType, [{
        key: "jsonV",
        value: function () {
          var _jsonV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    return _context.abrupt("return", JSON.stringify(this));

                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function jsonV() {
            return _jsonV.apply(this, arguments);
          }

          return jsonV;
        }()
      }, {
        key: "mapV",
        value: function () {
          var _mapV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var result;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.jsonV();

                  case 2:
                    result = _context2.sent;
                    return _context2.abrupt("return", result);

                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function mapV() {
            return _mapV.apply(this, arguments);
          }

          return mapV;
        }()
      }]);

      return AbstractType;
    }();

    var Reference = /*#__PURE__*/function (_AbstractType) {
      _inherits(Reference, _AbstractType);

      var _super = _createSuper(Reference);

      function Reference() {
        _classCallCheck(this, Reference);

        return _super.apply(this, arguments);
      }

      return _createClass(Reference);
    }(AbstractType);
    var reference = function reference(target) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$name = _ref.name,
          name = _ref$name === void 0 ? null : _ref$name,
          _ref$dumpall = _ref.dumpall,
          dumpall = _ref$dumpall === void 0 ? false : _ref$dumpall;

      name = name || "id";
      var targetT = target.constructor.name;
      var isReference = targetT === "string";
      var reserved = ["id", "_target", "_object", "_type", "__dict__"];

      var _Reference = /*#__PURE__*/function (_Reference2) {
        _inherits(_Reference, _Reference2);

        var _super2 = _createSuper(_Reference);

        function _Reference(id) {
          var _this;

          _classCallCheck(this, _Reference);

          _this = _super2.call(this, id);

          _this.__start__();

          var proxy = new Proxy(_assertThisInitialized(_this), {
            get: function get(target, name) {
              // special case to avoid this Proxy
              // breaking when being accessed in
              // an async context
              if (name === "then") return target.then;
              if (name in target) return target[name];
              var exists = Boolean(target._object && target._object[name]);
              if (exists) return target._object[name];
              if (target.isResolved) throw new AttributeError("'".concat(name, "' not found"));
              return target.get(name);
            },
            set: function set(target, name, value) {
              if (name in target) {
                target[name] = value;
                return true;
              } // verifies if the reference object exists in the current
              // reference instance, that's the case if the object name is
              // defined in the dictionary and the referenced object contains
              // an attribute with the name referred, for those situations
              // defers the setting of the attribute to the reference object


              var exists = target._object !== undefined && target._object[name] !== undefined;

              if (exists) {
                target._object[name] = value;
                return true;
              } // otherwise this is a normal attribute setting and the current
              // object's dictionary must be changed so that the new value is set


              target[name] = value;
              return true;
            }
          });
          if (id instanceof _Reference) return _possibleConstructorReturn(_this, _this.buildI(id));else if (id instanceof _this.constructor._target) return _possibleConstructorReturn(_this, _this.buildO(id));else _this.build(id);
          return _possibleConstructorReturn(_this, proxy);
        }

        _createClass(_Reference, [{
          key: "get",
          value: function () {
            var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(name) {
              var value;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return this.resolve();

                    case 2:
                      value = this._object[name];

                      if (!(value === undefined)) {
                        _context3.next = 5;
                        break;
                      }

                      throw new AttributeError("'".concat(name, "' not found"));

                    case 5:
                      return _context3.abrupt("return", value);

                    case 6:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function get(_x) {
              return _get.apply(this, arguments);
            }

            return get;
          }()
        }, {
          key: "set",
          value: function () {
            var _set = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(name, value) {
              var exists;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (reserved.includes(name)) {
                        _context4.next = 3;
                        break;
                      }

                      _context4.next = 3;
                      return target.resolve();

                    case 3:
                      // verifies if the reference object exists in the current
                      // reference instance, that's the case if the object name is
                      // defined in the dictionary and the referenced object contains
                      // an attribute with the name referred, for those situations
                      // defers the setting of the attribute to the reference object
                      exists = this._object !== undefined && this._object[name] !== undefined;

                      if (!exists) {
                        _context4.next = 7;
                        break;
                      }

                      this._object[name] = value;
                      return _context4.abrupt("return", true);

                    case 7:
                      // otherwise this is a normal attribute setting and the current
                      // object's dictionary must be changed so that the new value is set
                      this[name] = value;

                    case 8:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function set(_x2, _x3) {
              return _set.apply(this, arguments);
            }

            return set;
          }()
        }, {
          key: "__start__",
          value: function __start__() {
            if (isReference) this._target = this.constructor._target;else this._target = target;
            verify(this._target);
            var meta = this._target.schema[name];
            this._type = meta.type || String;
          }
          /**
           * The name of the key (join) attribute for the
           * reference that is going to be created, this
           * name may latter be used to cast the value
           */

        }, {
          key: "build",
          value: function build(id) {
            var cast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var isUnset = ["", null, undefined].includes(id);
            cast = cast && !isUnset;
            if (cast) id = this.constructor._target.cast(name, id);
            this.id = id;
            this._object = null;
          }
        }, {
          key: "buildI",
          value: function buildI(reference) {
            this.id = reference.id;
            this._object = reference._object;
          }
        }, {
          key: "buildO",
          value: function buildO(object) {
            this.id = object[this.constructor._name];
            this._object = object;
          }
        }, {
          key: "refV",
          value: function () {
            var _refV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      return _context5.abrupt("return", this.val);

                    case 1:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function refV() {
              return _refV.apply(this, arguments);
            }

            return refV;
          }()
        }, {
          key: "jsonV",
          value: function () {
            var _jsonV2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
              var result;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      if (!dumpall) {
                        _context6.next = 5;
                        break;
                      }

                      _context6.next = 3;
                      return this.resolve();

                    case 3:
                      result = _context6.sent;
                      return _context6.abrupt("return", result);

                    case 5:
                      return _context6.abrupt("return", this.val);

                    case 6:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function jsonV() {
              return _jsonV2.apply(this, arguments);
            }

            return jsonV;
          }()
        }, {
          key: "mapV",
          value: function () {
            var _mapV2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      throw new NotImplementedError();

                    case 1:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7);
            }));

            function mapV() {
              return _mapV2.apply(this, arguments);
            }

            return mapV;
          }()
        }, {
          key: "val",
          get: function get() {
            var isEmpty = ["", null, undefined].includes(this.id);
            if (isEmpty) return null;
            return this._type(this.id);
          }
        }, {
          key: "resolve",
          value: function () {
            var _resolve = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
              var kwargs,
                  exists,
                  _object2,
                  _object,
                  _args8 = arguments;

              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      kwargs = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
                      // verifies if the underlying object reference exists
                      // in the current names dictionary and if it exists
                      // verifies if it's valid (value is valid) if that's
                      // the case returns the current value immediately
                      exists = this._object !== undefined;

                      if (!(exists && this._object)) {
                        _context8.next = 4;
                        break;
                      }

                      return _context8.abrupt("return", this._object);

                    case 4:
                      if (this.id) {
                        _context8.next = 8;
                        break;
                      }

                      _object2 = null;
                      this._object = _object2;
                      return _context8.abrupt("return", _object2);

                    case 8:
                      // creates the map of keyword based arguments that are going
                      // to be used in the resolution of the reference and uses the
                      // data source based get attribute to retrieve the object
                      // that represents the reference
                      kwargs[name] = this.constructor._target.cast(name, this.id);
                      kwargs.raiseE = kwargs.raiseE || false;
                      kwargs.eagerL = kwargs.eagerL || false;
                      kwargs.resolveA = kwargs.resolveA || false;
                      _context8.next = 14;
                      return this.constructor._target.get(kwargs);

                    case 14:
                      _object = _context8.sent;
                      // sets the resolved object (using the current id attribute)
                      // in the current instance's dictionary and then returns this
                      // value to the caller method as the resolved value
                      this._object = _object;
                      return _context8.abrupt("return", _object);

                    case 17:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this);
            }));

            function resolve() {
              return _resolve.apply(this, arguments);
            }

            return resolve;
          }()
        }, {
          key: "isResolved",
          get: function get() {
            var exists = this._object !== undefined;
            return Boolean(exists && this._object);
          }
        }, {
          key: "isResolvable",
          value: function () {
            var _isResolvable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      _context9.next = 2;
                      return this.resolve();

                    case 2:
                      return _context9.abrupt("return", this._object !== null);

                    case 3:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function isResolvable() {
              return _isResolvable.apply(this, arguments);
            }

            return isResolvable;
          }()
        }], [{
          key: "schema",
          get: function get() {
            return target.schema;
          }
        }, {
          key: "schemaSafe",
          get: function get() {
            return target.schemaSafe;
          }
        }, {
          key: "collection",
          get: function get() {
            return target.collection;
          }
        }, {
          key: "idName",
          get: function get() {
            return "id";
          }
        }, {
          key: "increments",
          get: function get() {
            return target.increments;
          }
        }, {
          key: "dataOptions",
          get: function get() {
            return target.dataOptions;
          }
        }, {
          key: "_collection",
          value: function _collection(options) {
            return target._collection(options);
          }
        }, {
          key: "_increment",
          value: function () {
            var _increment2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(name) {
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      return _context10.abrupt("return", target._increment(name));

                    case 1:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10);
            }));

            function _increment(_x4) {
              return _increment2.apply(this, arguments);
            }

            return _increment;
          }()
        }, {
          key: "_ensureMin",
          value: function () {
            var _ensureMin2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(name, value) {
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      return _context11.abrupt("return", target._ensureMin(name, value));

                    case 1:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11);
            }));

            function _ensureMin(_x5, _x6) {
              return _ensureMin2.apply(this, arguments);
            }

            return _ensureMin;
          }()
        }, {
          key: "_eagerB",
          value: function _eagerB(eager) {
            return target._eagerB(eager);
          }
        }, {
          key: "_name",
          get: function get() {
            return name;
          }
        }, {
          key: "_default",
          get: function get() {
            return new this(null);
          }
        }, {
          key: "_target",
          get: function get() {
            if (isReference) {
              throw new NotImplementedError("References only work with classes, not class names");
            }

            return target;
          }
        }, {
          key: "_btype",
          value: function _btype() {
            var _target;

            if (isReference) _target = this._target();else _target = target;
            var meta = _target.schema[name];
            return meta.type || String;
          }
        }]);

        return _Reference;
      }(Reference);

      return _Reference;
    };
    var References = /*#__PURE__*/function (_AbstractType2) {
      _inherits(References, _AbstractType2);

      var _super3 = _createSuper(References);

      function References() {
        _classCallCheck(this, References);

        return _super3.apply(this, arguments);
      }

      return _createClass(References);
    }(AbstractType);
    var references = function references(target) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$name = _ref2.name,
          name = _ref2$name === void 0 ? undefined : _ref2$name,
          _ref2$dumpall = _ref2.dumpall,
          dumpall = _ref2$dumpall === void 0 ? false : _ref2$dumpall;

      name = name || "id";
      var targetT = target.constructor.name;
      var isReference = targetT === "string";
      var ReferenceC = reference(target, {
        name: name,
        dumpall: dumpall
      });

      var _References = /*#__PURE__*/function (_References2) {
        _inherits(_References, _References2);

        var _super4 = _createSuper(_References);

        function _References(ids) {
          var _this2;

          _classCallCheck(this, _References);

          _this2 = _super4.call(this, ids);

          _this2.__start__();

          var proxy = new Proxy(_assertThisInitialized(_this2), {
            get: function get(target, name) {
              if (name in target) return target[name];
              return target.objects[name];
            }
          });
          if (ids instanceof _References) return _possibleConstructorReturn(_this2, _this2.buildI(ids));else _this2.build(ids);
          return _possibleConstructorReturn(_this2, proxy);
        }

        _createClass(_References, [{
          key: "__start__",
          value: function __start__() {
            if (isReference) this._target = this.constructor._target;else this._target = target;
            verify(this._target);
          }
          /**
           * The name of the key (join) attribute for the
           * reference that is going to be created, this
           * name may latter be used to cast the value
           */

        }, {
          key: "items",
          get: function get() {
            return this.objects;
          }
        }, {
          key: "build",
          value: function build(ids) {
            var isValid = ![null, undefined].includes(ids);
            if (isValid && !Array.isArray(ids)) ids = [ids];
            this.ids = ids;
            this.objects = [];
            this.objectsM = {};
            this.setIds(this.ids);
          }
        }, {
          key: "buildI",
          value: function buildI(references) {
            this.ids = references.ids;
            this.objects = references.objects;
            this.objectsM = references.objectsM;
          }
        }, {
          key: "setIds",
          value: function setIds() {
            var _this3 = this;

            var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            this.ids = [];
            ids.forEach(function (id) {
              if (["", null, undefined].includes(id)) return;
              var object = new ReferenceC(id);
              var objectId = object.id;

              _this3.ids.push(objectId);

              _this3.objects.push(object);

              _this3.objectsM[objectId] = object;
            });
          }
        }, {
          key: "refV",
          value: function () {
            var _refV2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
              var result;
              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      _context13.next = 2;
                      return Promise.all(this.objects.map( /*#__PURE__*/function () {
                        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(object) {
                          return regeneratorRuntime.wrap(function _callee12$(_context12) {
                            while (1) {
                              switch (_context12.prev = _context12.next) {
                                case 0:
                                  _context12.next = 2;
                                  return object.refV();

                                case 2:
                                  return _context12.abrupt("return", _context12.sent);

                                case 3:
                                case "end":
                                  return _context12.stop();
                              }
                            }
                          }, _callee12);
                        }));

                        return function (_x7) {
                          return _ref3.apply(this, arguments);
                        };
                      }()));

                    case 2:
                      result = _context13.sent;
                      return _context13.abrupt("return", result);

                    case 4:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13, this);
            }));

            function refV() {
              return _refV2.apply(this, arguments);
            }

            return refV;
          }()
        }, {
          key: "jsonV",
          value: function () {
            var _jsonV3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
              var result;
              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      _context15.next = 2;
                      return Promise.all(this.objects.map( /*#__PURE__*/function () {
                        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(object) {
                          return regeneratorRuntime.wrap(function _callee14$(_context14) {
                            while (1) {
                              switch (_context14.prev = _context14.next) {
                                case 0:
                                  _context14.next = 2;
                                  return object.jsonV();

                                case 2:
                                  return _context14.abrupt("return", _context14.sent);

                                case 3:
                                case "end":
                                  return _context14.stop();
                              }
                            }
                          }, _callee14);
                        }));

                        return function (_x8) {
                          return _ref4.apply(this, arguments);
                        };
                      }()));

                    case 2:
                      result = _context15.sent;
                      return _context15.abrupt("return", result);

                    case 4:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15, this);
            }));

            function jsonV() {
              return _jsonV3.apply(this, arguments);
            }

            return jsonV;
          }()
        }, {
          key: "mapV",
          value: function () {
            var _mapV3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
              var result;
              return regeneratorRuntime.wrap(function _callee17$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      _context17.next = 2;
                      return Promise.all(this.objects.map( /*#__PURE__*/function () {
                        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(object) {
                          return regeneratorRuntime.wrap(function _callee16$(_context16) {
                            while (1) {
                              switch (_context16.prev = _context16.next) {
                                case 0:
                                  _context16.next = 2;
                                  return object.mapV();

                                case 2:
                                  return _context16.abrupt("return", _context16.sent);

                                case 3:
                                case "end":
                                  return _context16.stop();
                              }
                            }
                          }, _callee16);
                        }));

                        return function (_x9) {
                          return _ref5.apply(this, arguments);
                        };
                      }()));

                    case 2:
                      result = _context17.sent;
                      return _context17.abrupt("return", result);

                    case 4:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee17, this);
            }));

            function mapV() {
              return _mapV3.apply(this, arguments);
            }

            return mapV;
          }()
        }, {
          key: "val",
          get: function get() {
            return this.objects.map(function (object) {
              return object.val;
            });
          }
        }, {
          key: "list",
          get: function get() {
            return this.objects.map(function (object) {
              return object.val;
            });
          }
        }, {
          key: "resolve",
          value: function () {
            var _resolve2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
              var kwargs,
                  result,
                  _args18 = arguments;
              return regeneratorRuntime.wrap(function _callee18$(_context18) {
                while (1) {
                  switch (_context18.prev = _context18.next) {
                    case 0:
                      kwargs = _args18.length > 0 && _args18[0] !== undefined ? _args18[0] : {};
                      _context18.next = 3;
                      return Promise.all(this.objects.map(function (object) {
                        return object.resolve(kwargs);
                      }));

                    case 3:
                      result = _context18.sent;
                      return _context18.abrupt("return", result);

                    case 5:
                    case "end":
                      return _context18.stop();
                  }
                }
              }, _callee18, this);
            }));

            function resolve() {
              return _resolve2.apply(this, arguments);
            }

            return resolve;
          }()
        }, {
          key: "find",
          value: function find() {
            var _this4 = this;

            var kwargs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            kwargs[name] = {
              $in: this.ids.map(function (id) {
                return _this4._target.cast(name, id);
              })
            };
            return this._target.find(kwargs);
          }
        }, {
          key: "paginate",
          value: function paginate() {
            var _this5 = this;

            var kwargs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            kwargs[name] = {
              $in: this.ids.map(function (id) {
                return _this5._target.cast(name, id);
              })
            };
            return this._target.paginate(kwargs);
          }
        }, {
          key: "isEmpty",
          get: function get() {
            var idsL = self.ids.length;
            return idsL === 0;
          }
        }, {
          key: "isResolved",
          get: function get() {
            if (this.objects.length === 0) return true;
            return this.objects[0].isResolved;
          }
        }], [{
          key: "_name",
          get: function get() {
            return name;
          }
        }, {
          key: "_default",
          get: function get() {
            return new this([]);
          }
        }, {
          key: "_target",
          get: function get() {
            return ReferenceC._target;
          }
        }, {
          key: "_btype",
          value: function _btype() {
            return ReferenceC._btype;
          }
        }]);

        return _References;
      }(References);

      return _References;
    };

    /**
     * A mapping from yonius types to the schema types to
     * be used by the underlying Mongo collection.
     */

    var MONGO_TYPES = [[Reference, Object], [References, Array]];
    /**
     * Abstract class definition that defines the interface
     * expected to be implemented by data driven collections
     * in the Yonius context.
     */

    var Collection = /*#__PURE__*/function () {
      function Collection(options) {
        _classCallCheck(this, Collection);

        this.options = options;
      }

      _createClass(Collection, [{
        key: "find",
        value: function () {
          var _find = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(conditions) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    throw new NotImplementedError();

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function find(_x) {
            return _find.apply(this, arguments);
          }

          return find;
        }()
      }, {
        key: "findOne",
        value: function () {
          var _findOne = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(conditions) {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    throw new NotImplementedError();

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function findOne(_x2) {
            return _findOne.apply(this, arguments);
          }

          return findOne;
        }()
      }, {
        key: "findOneAndUpdate",
        value: function () {
          var _findOneAndUpdate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(conditions, data) {
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    throw new NotImplementedError();

                  case 2:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function findOneAndUpdate(_x3, _x4) {
            return _findOneAndUpdate.apply(this, arguments);
          }

          return findOneAndUpdate;
        }()
      }, {
        key: "findOneAndDelete",
        value: function () {
          var _findOneAndDelete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(conditions) {
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    throw new NotImplementedError();

                  case 2:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          function findOneAndDelete(_x5) {
            return _findOneAndDelete.apply(this, arguments);
          }

          return findOneAndDelete;
        }()
      }, {
        key: "create",
        value: function () {
          var _create = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(data) {
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    throw new NotImplementedError();

                  case 2:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));

          function create(_x6) {
            return _create.apply(this, arguments);
          }

          return create;
        }()
      }, {
        key: "count",
        value: function () {
          var _count = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(conditions) {
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    throw new NotImplementedError();

                  case 2:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));

          function count(_x7) {
            return _count.apply(this, arguments);
          }

          return count;
        }()
      }]);

      return Collection;
    }();
    /**
     * Mongo based collection that implements the collection
     * abstract interface applying it to a specific mongodb
     * instance. Most of the interface is already "mongodb
     * oriented", so only a thin layer of adaptation is required.
     */

    var MongoCollection = /*#__PURE__*/function (_Collection) {
      _inherits(MongoCollection, _Collection);

      var _super = _createSuper(MongoCollection);

      function MongoCollection(name, schema) {
        var _this;

        _classCallCheck(this, MongoCollection);

        _this = _super.call(this, name, schema);
        _this._mongoose = _this.constructor.getModel(_this.options.name, _this.options.schema);
        return _this;
      }

      _createClass(MongoCollection, [{
        key: "find",
        value: function () {
          var _find2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(conditions) {
            var projection,
                options,
                model,
                _args7 = arguments;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    projection = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
                    options = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {};
                    _context7.next = 4;
                    return this._mongoose.find(conditions, projection, options);

                  case 4:
                    model = _context7.sent;
                    return _context7.abrupt("return", model);

                  case 6:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function find(_x8) {
            return _find2.apply(this, arguments);
          }

          return find;
        }()
      }, {
        key: "findOne",
        value: function () {
          var _findOne2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(conditions) {
            var projection,
                options,
                model,
                _args8 = arguments;
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    projection = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                    options = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {};
                    model = this._mongoose.findOne(conditions, projection, options);
                    return _context8.abrupt("return", model);

                  case 4:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));

          function findOne(_x9) {
            return _findOne2.apply(this, arguments);
          }

          return findOne;
        }()
      }, {
        key: "findOneAndUpdate",
        value: function () {
          var _findOneAndUpdate2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(conditions, data) {
            var options,
                model,
                _args9 = arguments;
            return regeneratorRuntime.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    options = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : {};
                    _context9.next = 3;
                    return this._mongoose.findOneAndUpdate(conditions, data, _objectSpread2({
                      upsert: true,
                      "new": true
                    }, options));

                  case 3:
                    model = _context9.sent;
                    return _context9.abrupt("return", model);

                  case 5:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));

          function findOneAndUpdate(_x10, _x11) {
            return _findOneAndUpdate2.apply(this, arguments);
          }

          return findOneAndUpdate;
        }()
      }, {
        key: "findOneAndDelete",
        value: function () {
          var _findOneAndDelete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(conditions) {
            var options,
                model,
                _args10 = arguments;
            return regeneratorRuntime.wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    options = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};
                    _context10.next = 3;
                    return this._mongoose.findOneAndDelete(conditions, options);

                  case 3:
                    model = _context10.sent;
                    return _context10.abrupt("return", model);

                  case 5:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this);
          }));

          function findOneAndDelete(_x12) {
            return _findOneAndDelete2.apply(this, arguments);
          }

          return findOneAndDelete;
        }()
      }, {
        key: "create",
        value: function () {
          var _create2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(data) {
            var options,
                models,
                _args11 = arguments;
            return regeneratorRuntime.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    options = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};
                    _context11.next = 3;
                    return this._mongoose.create([data], options);

                  case 3:
                    models = _context11.sent;
                    return _context11.abrupt("return", models[0]);

                  case 5:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));

          function create(_x13) {
            return _create2.apply(this, arguments);
          }

          return create;
        }()
      }, {
        key: "count",
        value: function () {
          var _count2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(conditions) {
            var count;
            return regeneratorRuntime.wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.next = 3;
                    return this._mongoose.countDocuments(conditions);

                  case 3:
                    count = _context12.sent;
                    return _context12.abrupt("return", count);

                  case 5:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this);
          }));

          function count(_x14) {
            return _count2.apply(this, arguments);
          }

          return count;
        }()
      }], [{
        key: "getModel",
        value: function getModel(name, schema) {
          // verifies if the model is already present in the global
          // cache and if that the case re-uses it
          this._models = this._models || {};
          if (this._models[name]) return this._models[name]; // obtains a reference to the mongoose, that
          // should have been registered by 3rd party

          var mongoose = request("mongoose"); // creates the internal "mongoose" reference to the
          // model by encapsulating its name and schema

          var filteredSchema = _objectSpread2({}, schema);

          Object.entries(filteredSchema).forEach(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                name = _ref2[0],
                value = _ref2[1];

            var found = MONGO_TYPES.find(function (_ref3) {
              var _ref4 = _slicedToArray(_ref3, 2),
                  type = _ref4[0];
                  _ref4[1];

              return value.type.prototype instanceof type;
            });
            if (!found) return;
            filteredSchema[name].type = found[1];
          });
          this._models[name] = mongoose.model(name, new mongoose.Schema(filteredSchema)); // returns the newly constructor mongoose model to
          // the caller methods

          return this._models[name];
        }
      }]);

      return MongoCollection;
    }(Collection);

    var collection = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Collection: Collection,
        MongoCollection: MongoCollection,
        'default': Collection
    });

    var _BUILDERS;
    var MEMORY_STORAGE = {};
    /**
     * Simple lambda function that removes any
     * empty element from the provided list values
     */

    var RE = function RE(v) {
      return v.filter(function (i) {
        return i !== "";
      });
    };
    /**
     * The map associating the various types with the
     * custom builder functions to be used when applying
     * the types function, this is relevant for the built-in
     * types that are meant to avoid using the default constructor
     */


    var BUILDERS = (_BUILDERS = {}, _defineProperty(_BUILDERS, Number, function (v) {
      return v;
    }), _defineProperty(_BUILDERS, String, function (v) {
      return v;
    }), _defineProperty(_BUILDERS, Array, function (v) {
      return Array.isArray(v) ? RE(v) : typeof v === "string" ? JSON.parse(v) : RE([v]);
    }), _defineProperty(_BUILDERS, Boolean, function (v) {
      return typeof v === "boolean" ? v : !["", "0", "false", "False"].includes(v);
    }), _defineProperty(_BUILDERS, Object, function (v) {
      return typeof v === "string" ? JSON.parse(v) : v;
    }), _BUILDERS);
    /**
     * The default values to be set when a type
     * conversion fails for the provided string value
     * the resulting value may be returned when a validation
     * fails an so it must be used carefully
     */

    var TYPE_DEFAULTS = {
      bytes: null,
      unicode: null,
      "int": null,
      "float": null,
      bool: false,
      list: function list() {
        return [];
      },
      dict: function dict() {
        return {};
      },
      object: function object() {
        return {};
      }
    };
    /**
     * The various data types that are considered to be references
     * so that they are lazy loaded from the data source, these kind
     * of types should be compliant to a common interface so that they
     * may be used "blindly" from an external entity
     */

    var TYPE_REFERENCES = [Reference, References];
    /**
     * The map that associates the various operators with the boolean
     * values that define if an insensitive base search should be used
     * instead of the "typical" sensitive search.
     */

    var INSENSITIVE = {
      likei: true,
      llikei: true,
      rlikei: true
    };
    /**
     * The map containing the mapping association between the
     * normalized version of the operators and the infra-structure
     * specific value for each of this operations, note that some
     * of the values don't have a valid mapping for this operations
     * the operator must be ignored and not used explicitly.
     */

    var OPERATORS = {
      eq: null,
      equals: null,
      ne: "$ne",
      not_equals: "$ne",
      "in": "$in",
      nin: "$nin",
      not_in: "$nin",
      like: "$regex",
      likei: "$regex",
      llike: "$regex",
      llikei: "$regex",
      rlike: "$regex",
      rlikei: "$regex",
      gt: "$gt",
      greater: "$gt",
      gte: "$gte",
      greater_equal: "$gte",
      lt: "$lt",
      lesser: "$lt",
      lte: "$lte",
      lesser_equal: "$lte",
      "null": null,
      is_null: null,
      not_null: "$ne",
      is_not_null: "$ne",
      contains: "$all"
    };
    /**
     * Map that associates each of the normalized operations with
     * an inline function that together with the data type maps the
     * the base string based value into the target normalized value.
     */

    var VALUE_METHODS = {
      "in": function _in(v, t) {
        return v.split(";").map(t);
      },
      not_in: function not_in(v, t) {
        return v.split(";").map(t);
      },
      like: function like(v, t) {
        return "^.*" + escapeStringRegexp(v) + ".*$";
      },
      likei: function likei(v, t) {
        return "^.*" + escapeStringRegexp(v) + ".*$";
      },
      llike: function llike(v, t) {
        return "^.*" + escapeStringRegexp(v) + "$";
      },
      llikei: function llikei(v, t) {
        return "^.*" + escapeStringRegexp(v) + "$";
      },
      rlike: function rlike(v, t) {
        return "^" + escapeStringRegexp(v) + ".*$";
      },
      rlikei: function rlikei(v, t) {
        return "^" + escapeStringRegexp(v) + ".*$";
      },
      "null": function _null(v, t) {
        return null;
      },
      is_null: function is_null(v, t) {
        return null;
      },
      not_null: function not_null(v, t) {
        return null;
      },
      is_not_null: function is_not_null(v, t) {
        return null;
      },
      contains: function contains(v, t) {
        return v.split(";").map(t);
      }
    };
    var Model = /*#__PURE__*/function () {
      function Model() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Model);

        var fill = options.fill === undefined ? true : options.fill;
        if (fill) this.constructor.fill(this);
      }

      _createClass(Model, [{
        key: "validate",
        value: function () {
          var _validate2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var errors;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    errors = _toConsumableArray(this._validate());

                    if (!errors.length) {
                      _context.next = 3;
                      break;
                    }

                    throw new ValidationError("Invalid model: ".concat(errors.map(function (err) {
                      return String(err);
                    }).join(", ")));

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function validate() {
            return _validate2.apply(this, arguments);
          }

          return validate;
        }()
      }, {
        key: "apply",
        value: function () {
          var _apply = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(model) {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.wrap(model);

                  case 2:
                    return _context2.abrupt("return", this);

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function apply(_x) {
            return _apply.apply(this, arguments);
          }

          return apply;
        }()
      }, {
        key: "wrap",
        value: function () {
          var _wrap2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(model) {
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._wrap(model);

                  case 2:
                    return _context3.abrupt("return", this);

                  case 3:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function wrap(_x2) {
            return _wrap2.apply(this, arguments);
          }

          return wrap;
        }()
      }, {
        key: "isNew",
        get: function get() {
          return this._id === undefined;
        }
      }, {
        key: "model",
        get: function get() {
          return this;
        }
      }, {
        key: "jsonV",
        value: function () {
          var _jsonV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    return _context4.abrupt("return", this.model);

                  case 1:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function jsonV() {
            return _jsonV.apply(this, arguments);
          }

          return jsonV;
        }()
      }, {
        key: "string",
        get: function get() {
          return JSON.stringify(this.model);
        }
        /**
         * Wraps the provided model object around the current instance, making
         * sure that all of the elements are compliant with the schema.
         *
         * It should be possible to override the `_wrap` operation to implement
         * a custom "way" of setting data into a model.
         *
         * @param {Object} model The model structure that is going to be used
         * to wrap the current model object, meaning that all of its elements
         * are going to be stored in the current object.
         */

      }, {
        key: "_wrap",
        value: function () {
          var _wrap3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(model) {
            var _i, _Object$keys, key, value;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _i = 0, _Object$keys = Object.keys(this.constructor.schema);

                  case 1:
                    if (!(_i < _Object$keys.length)) {
                      _context5.next = 10;
                      break;
                    }

                    key = _Object$keys[_i];
                    value = model[key];

                    if (!(value === undefined)) {
                      _context5.next = 6;
                      break;
                    }

                    return _context5.abrupt("continue", 7);

                  case 6:
                    this[key] = this.constructor.cast(key, value);

                  case 7:
                    _i++;
                    _context5.next = 1;
                    break;

                  case 10:
                    if (model._id !== undefined) this._id = model._id;

                  case 11:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function _wrap(_x3) {
            return _wrap3.apply(this, arguments);
          }

          return _wrap;
        }()
      }, {
        key: "_validate",
        value: /*#__PURE__*/regeneratorRuntime.mark(function _validate() {
          var _i2, _Object$entries, _Object$entries$_i, name, value, validation, _iterator, _step, callable;

          return regeneratorRuntime.wrap(function _validate$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _i2 = 0, _Object$entries = Object.entries(this.constructor.schema);

                case 1:
                  if (!(_i2 < _Object$entries.length)) {
                    _context6.next = 32;
                    break;
                  }

                  _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), name = _Object$entries$_i[0], value = _Object$entries$_i[1];
                  validation = value.validation || false;

                  if (validation) {
                    _context6.next = 6;
                    break;
                  }

                  return _context6.abrupt("continue", 29);

                case 6:
                  _iterator = _createForOfIteratorHelper(validation);
                  _context6.prev = 7;

                  _iterator.s();

                case 9:
                  if ((_step = _iterator.n()).done) {
                    _context6.next = 21;
                    break;
                  }

                  callable = _step.value;
                  _context6.prev = 11;
                  callable(this[name]);
                  _context6.next = 19;
                  break;

                case 15:
                  _context6.prev = 15;
                  _context6.t0 = _context6["catch"](11);
                  _context6.next = 19;
                  return _context6.t0;

                case 19:
                  _context6.next = 9;
                  break;

                case 21:
                  _context6.next = 26;
                  break;

                case 23:
                  _context6.prev = 23;
                  _context6.t1 = _context6["catch"](7);

                  _iterator.e(_context6.t1);

                case 26:
                  _context6.prev = 26;

                  _iterator.f();

                  return _context6.finish(26);

                case 29:
                  _i2++;
                  _context6.next = 1;
                  break;

                case 32:
                case "end":
                  return _context6.stop();
              }
            }
          }, _validate, this, [[7, 23, 26, 29], [11, 15]]);
        })
      }], [{
        key: "niw",
        value: function niw() {
          return new this();
        }
        /**
         * Fills the current model with the proper values so that
         * no values are unset as this would violate the model definition
         * integrity. This is required when retrieving an object(s) from
         * the data source (as some of them may be incomplete).
         *
         * @param {Object} model The model that is going to have its unset
         * attributes filled with "default" data, in case none is provided
         * all of the attributes will be filled with "default" data.
         * @param {Boolean} safe If the safe mode should be used for the fill
         * operation meaning that under some conditions no unit fill
         * operation is going to be applied (eg: retrieval operations).
         */

      }, {
        key: "fill",
        value: function () {
          var _fill = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
            var model,
                safe,
                _i3,
                _Object$entries2,
                _Object$entries2$_i,
                name,
                field,
                _private,
                increment,
                initial,
                type,
                _default,
                _args7 = arguments;

            return regeneratorRuntime.wrap(function _callee6$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    model = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};
                    safe = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : false;
                    _i3 = 0, _Object$entries2 = Object.entries(this.schema);

                  case 3:
                    if (!(_i3 < _Object$entries2.length)) {
                      _context7.next = 19;
                      break;
                    }

                    _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2), name = _Object$entries2$_i[0], field = _Object$entries2$_i[1];

                    if (!(model[name] !== undefined)) {
                      _context7.next = 7;
                      break;
                    }

                    return _context7.abrupt("continue", 16);

                  case 7:
                    if (!["_id"].includes(model[name])) {
                      _context7.next = 9;
                      break;
                    }

                    return _context7.abrupt("continue", 16);

                  case 9:
                    _private = field["private"] === undefined ? false : field["private"];
                    increment = field.increment === undefined ? false : field.increment;

                    if (!(_private && safe)) {
                      _context7.next = 13;
                      break;
                    }

                    return _context7.abrupt("continue", 16);

                  case 13:
                    if (!increment) {
                      _context7.next = 15;
                      break;
                    }

                    return _context7.abrupt("continue", 16);

                  case 15:
                    if (field.initial !== undefined) {
                      initial = field.initial;
                      model[name] = initial;
                    } else {
                      type = field.type || null;
                      _default = typeD(type, null);
                      _default = type._default === undefined ? _default : type._default();
                      model[name] = _default;
                    }

                  case 16:
                    _i3++;
                    _context7.next = 3;
                    break;

                  case 19:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee6, this);
          }));

          function fill() {
            return _fill.apply(this, arguments);
          }

          return fill;
        }()
      }, {
        key: "cast",
        value: function cast(name, value) {
          var safe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          if (!this.schema[name]) return value;
          if (value === null || value === undefined) return value;

          var _definition = this.definitionN(name);

          var _type = _definition.type || String;

          var builder = BUILDERS[_type] || function (v) {
            return new _type(v);
          };

          try {
            return builder ? builder(value) : value;
          } catch (err) {
            if (!safe) throw err;

            var _default = this.typeD[_type] || null;

            _default = _type._default ? _type._default() : _default;
            return _default;
          }
        }
      }, {
        key: "eagers",
        get: function get() {
          return Object.entries(this.schema).filter(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2);
                _ref2[0];
                var field = _ref2[1];

            return field.eager;
          }).map(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                name = _ref4[0];
                _ref4[1];

            return name;
          });
        }
        /**
         * The name of the data source adapter that is going
         * to be used to handle this model instance.
         *
         * @type {String}
         */

      }, {
        key: "adapter",
        get: function get() {
          return process.env.ADAPTER || "mongo";
        }
      }]);

      return Model;
    }();
    var ModelStore = /*#__PURE__*/function (_Model) {
      _inherits(ModelStore, _Model);

      var _super = _createSuper(ModelStore);

      function ModelStore() {
        _classCallCheck(this, ModelStore);

        return _super.apply(this, arguments);
      }

      _createClass(ModelStore, [{
        key: "save",
        value: function () {
          var _save = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
            var _ref5,
                _ref5$validate,
                validate,
                _ref5$incrementA,
                incrementA,
                _ref5$immutablesA,
                immutablesA,
                _ref5$preSave,
                preSave,
                _ref5$preCreate,
                preCreate,
                _ref5$preUpdate,
                preUpdate,
                _ref5$postSave,
                postSave,
                _ref5$postCreate,
                postCreate,
                _ref5$postUpdate,
                postUpdate,
                _ref5$beforeCallbacks,
                beforeCallbacks,
                _ref5$afterCallbacks,
                afterCallbacks,
                model,
                _iterator2,
                _step2,
                callback,
                isNew,
                conditions,
                _iterator3,
                _step3,
                _callback,
                _args8 = arguments;

            return regeneratorRuntime.wrap(function _callee7$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _ref5 = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {}, _ref5$validate = _ref5.validate, validate = _ref5$validate === void 0 ? true : _ref5$validate, _ref5$incrementA = _ref5.incrementA, incrementA = _ref5$incrementA === void 0 ? undefined : _ref5$incrementA, _ref5$immutablesA = _ref5.immutablesA, immutablesA = _ref5$immutablesA === void 0 ? undefined : _ref5$immutablesA, _ref5$preSave = _ref5.preSave, preSave = _ref5$preSave === void 0 ? true : _ref5$preSave, _ref5$preCreate = _ref5.preCreate, preCreate = _ref5$preCreate === void 0 ? true : _ref5$preCreate, _ref5$preUpdate = _ref5.preUpdate, preUpdate = _ref5$preUpdate === void 0 ? true : _ref5$preUpdate, _ref5$postSave = _ref5.postSave, postSave = _ref5$postSave === void 0 ? true : _ref5$postSave, _ref5$postCreate = _ref5.postCreate, postCreate = _ref5$postCreate === void 0 ? true : _ref5$postCreate, _ref5$postUpdate = _ref5.postUpdate, postUpdate = _ref5$postUpdate === void 0 ? true : _ref5$postUpdate, _ref5$beforeCallbacks = _ref5.beforeCallbacks, beforeCallbacks = _ref5$beforeCallbacks === void 0 ? [] : _ref5$beforeCallbacks, _ref5$afterCallbacks = _ref5.afterCallbacks, afterCallbacks = _ref5$afterCallbacks === void 0 ? [] : _ref5$afterCallbacks;

                    if (!validate) {
                      _context8.next = 4;
                      break;
                    }

                    _context8.next = 4;
                    return this.validate();

                  case 4:
                    if (!preSave) {
                      _context8.next = 7;
                      break;
                    }

                    _context8.next = 7;
                    return this.preSave();

                  case 7:
                    if (!preCreate) {
                      _context8.next = 10;
                      break;
                    }

                    _context8.next = 10;
                    return this.preCreate();

                  case 10:
                    if (!preUpdate) {
                      _context8.next = 13;
                      break;
                    }

                    _context8.next = 13;
                    return this.preUpdate();

                  case 13:
                    _context8.next = 15;
                    return this._filter({
                      incrementA: incrementA,
                      immutablesA: immutablesA,
                      normalize: true
                    });

                  case 15:
                    model = _context8.sent;
                    _context8.next = 18;
                    return this.verify(model);

                  case 18:
                    // calls the complete set of callbacks that should be called
                    // before the concrete data store save operation
                    _iterator2 = _createForOfIteratorHelper(beforeCallbacks);
                    _context8.prev = 19;

                    _iterator2.s();

                  case 21:
                    if ((_step2 = _iterator2.n()).done) {
                      _context8.next = 27;
                      break;
                    }

                    callback = _step2.value;
                    _context8.next = 25;
                    return callback(this, this.model);

                  case 25:
                    _context8.next = 21;
                    break;

                  case 27:
                    _context8.next = 32;
                    break;

                  case 29:
                    _context8.prev = 29;
                    _context8.t0 = _context8["catch"](19);

                    _iterator2.e(_context8.t0);

                  case 32:
                    _context8.prev = 32;

                    _iterator2.f();

                    return _context8.finish(32);

                  case 35:
                    // verifies if the current model is a new one or if instead
                    // represents an update to a previously stored model and create
                    // or update data accordingly
                    isNew = this._id === undefined;

                    if (!isNew) {
                      _context8.next = 42;
                      break;
                    }

                    _context8.next = 39;
                    return this.constructor.collection.create(model);

                  case 39:
                    model = _context8.sent;
                    _context8.next = 47;
                    break;

                  case 42:
                    conditions = {};
                    conditions[this.constructor.idName] = this.identifier;
                    _context8.next = 46;
                    return this.constructor.collection.findOneAndUpdate(conditions, model);

                  case 46:
                    model = _context8.sent;

                  case 47:
                    // wraps the model object using the current instance
                    // effectively making the data available for consumers
                    this.wrap(model); // calls the complete set of callbacks that should be called
                    // after the concrete data store save operation

                    _iterator3 = _createForOfIteratorHelper(afterCallbacks);
                    _context8.prev = 49;

                    _iterator3.s();

                  case 51:
                    if ((_step3 = _iterator3.n()).done) {
                      _context8.next = 57;
                      break;
                    }

                    _callback = _step3.value;
                    _context8.next = 55;
                    return _callback(this, this.model);

                  case 55:
                    _context8.next = 51;
                    break;

                  case 57:
                    _context8.next = 62;
                    break;

                  case 59:
                    _context8.prev = 59;
                    _context8.t1 = _context8["catch"](49);

                    _iterator3.e(_context8.t1);

                  case 62:
                    _context8.prev = 62;

                    _iterator3.f();

                    return _context8.finish(62);

                  case 65:
                    if (!postSave) {
                      _context8.next = 68;
                      break;
                    }

                    _context8.next = 68;
                    return this.postSave();

                  case 68:
                    if (!postCreate) {
                      _context8.next = 71;
                      break;
                    }

                    _context8.next = 71;
                    return this.postCreate();

                  case 71:
                    if (!postUpdate) {
                      _context8.next = 74;
                      break;
                    }

                    _context8.next = 74;
                    return this.postUpdate();

                  case 74:
                    return _context8.abrupt("return", this);

                  case 75:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee7, this, [[19, 29, 32, 35], [49, 59, 62, 65]]);
          }));

          function save() {
            return _save.apply(this, arguments);
          }

          return save;
        }()
      }, {
        key: "delete",
        value: function () {
          var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
            var _ref6,
                _ref6$preDelete,
                preDelete,
                _ref6$postDelete,
                postDelete,
                _ref6$beforeCallbacks,
                beforeCallbacks,
                _ref6$afterCallbacks,
                afterCallbacks,
                _iterator4,
                _step4,
                callback,
                conditions,
                _iterator5,
                _step5,
                _callback2,
                _args9 = arguments;

            return regeneratorRuntime.wrap(function _callee8$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    _ref6 = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : {}, _ref6$preDelete = _ref6.preDelete, preDelete = _ref6$preDelete === void 0 ? true : _ref6$preDelete, _ref6$postDelete = _ref6.postDelete, postDelete = _ref6$postDelete === void 0 ? true : _ref6$postDelete, _ref6$beforeCallbacks = _ref6.beforeCallbacks, beforeCallbacks = _ref6$beforeCallbacks === void 0 ? [] : _ref6$beforeCallbacks, _ref6$afterCallbacks = _ref6.afterCallbacks, afterCallbacks = _ref6$afterCallbacks === void 0 ? [] : _ref6$afterCallbacks;

                    if (!preDelete) {
                      _context9.next = 4;
                      break;
                    }

                    _context9.next = 4;
                    return this.preDelete();

                  case 4:
                    // calls the complete set of callbacks that should be called
                    // before the concrete data store delete operation
                    _iterator4 = _createForOfIteratorHelper(beforeCallbacks);
                    _context9.prev = 5;

                    _iterator4.s();

                  case 7:
                    if ((_step4 = _iterator4.n()).done) {
                      _context9.next = 13;
                      break;
                    }

                    callback = _step4.value;
                    _context9.next = 11;
                    return callback(this, this.model);

                  case 11:
                    _context9.next = 7;
                    break;

                  case 13:
                    _context9.next = 18;
                    break;

                  case 15:
                    _context9.prev = 15;
                    _context9.t0 = _context9["catch"](5);

                    _iterator4.e(_context9.t0);

                  case 18:
                    _context9.prev = 18;

                    _iterator4.f();

                    return _context9.finish(18);

                  case 21:
                    // builds the set of conditions that rare going to be used for
                    // the concrete delete operation to be performed
                    conditions = {};
                    conditions[this.constructor.idName] = this.identifier;
                    _context9.next = 25;
                    return this.constructor.collection.findOneAndDelete(conditions);

                  case 25:
                    // calls the complete set of callbacks that should be called
                    // after the concrete data store delete operation
                    _iterator5 = _createForOfIteratorHelper(afterCallbacks);
                    _context9.prev = 26;

                    _iterator5.s();

                  case 28:
                    if ((_step5 = _iterator5.n()).done) {
                      _context9.next = 34;
                      break;
                    }

                    _callback2 = _step5.value;
                    _context9.next = 32;
                    return _callback2(this, this.model);

                  case 32:
                    _context9.next = 28;
                    break;

                  case 34:
                    _context9.next = 39;
                    break;

                  case 36:
                    _context9.prev = 36;
                    _context9.t1 = _context9["catch"](26);

                    _iterator5.e(_context9.t1);

                  case 39:
                    _context9.prev = 39;

                    _iterator5.f();

                    return _context9.finish(39);

                  case 42:
                    if (!postDelete) {
                      _context9.next = 45;
                      break;
                    }

                    _context9.next = 45;
                    return this.postDelete();

                  case 45:
                    return _context9.abrupt("return", this);

                  case 46:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee8, this, [[5, 15, 18, 21], [26, 36, 39, 42]]);
          }));

          function _delete() {
            return _delete2.apply(this, arguments);
          }

          return _delete;
        }()
      }, {
        key: "advance",
        value: function () {
          var _advance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(name) {
            var delta,
                conditions,
                increments,
                value,
                _value,
                _args10 = arguments;

            return regeneratorRuntime.wrap(function _callee9$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    delta = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : 1;
                    conditions = {};
                    conditions[this.constructor.idName] = this.identifier;
                    increments = {};
                    increments[name] = delta;
                    _context10.next = 7;
                    return this.constructor.collection.findOneAndUpdate(conditions, {
                      $inc: increments
                    }, {
                      "new": true
                    });

                  case 7:
                    value = _context10.sent;
                    _context10.t0 = value;

                    if (_context10.t0) {
                      _context10.next = 13;
                      break;
                    }

                    _context10.next = 12;
                    return this.constructor.collection.find_one(conditions);

                  case 12:
                    _context10.t0 = _context10.sent;

                  case 13:
                    value = _context10.t0;
                    _value = value[name];
                    this[name] = _value;
                    return _context10.abrupt("return", _value);

                  case 17:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee9, this);
          }));

          function advance(_x4) {
            return _advance.apply(this, arguments);
          }

          return advance;
        }()
      }, {
        key: "reload",
        value: function () {
          var _reload = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
            var params,
                model,
                _args11 = arguments;
            return regeneratorRuntime.wrap(function _callee10$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    params = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};

                    if (!this.isNew) {
                      _context11.next = 3;
                      break;
                    }

                    throw new OperationalError("Can't reload a new model entity", 412);

                  case 3:
                    _context11.next = 5;
                    return this.constructor.get(_objectSpread2(_objectSpread2({}, params), {}, {
                      _id: this._id
                    }));

                  case 5:
                    model = _context11.sent;
                    return _context11.abrupt("return", model);

                  case 7:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee10, this);
          }));

          function reload() {
            return _reload.apply(this, arguments);
          }

          return reload;
        }()
        /**
         * Runs a series of assertions on the current model
         * definition raising assertion errors in case there
         * are issues with the internal structure of it.
         *
         * @param {Object} model The model that is going to
         * be verified for a series of elements.
         */

      }, {
        key: "verify",
        value: function () {
          var _verify2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(model) {
            var _i4, _Object$entries3, _Object$entries3$_i, name, field;

            return regeneratorRuntime.wrap(function _callee11$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    verify(this.getIdentifier(model) !== undefined && this.getIdentifier(model) !== null, "The identifier must be defined before saving", 400, OperationalError);

                    for (_i4 = 0, _Object$entries3 = Object.entries(this.constructor.schema); _i4 < _Object$entries3.length; _i4++) {
                      _Object$entries3$_i = _slicedToArray(_Object$entries3[_i4], 2), name = _Object$entries3$_i[0], field = _Object$entries3$_i[1];

                      verify(!field.required || ![undefined, null].includes(model[name]), "No value provided for mandatory field '".concat(name, "'"), 400, OperationalError);
                    }

                  case 2:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee11, this);
          }));

          function verify$1(_x5) {
            return _verify2.apply(this, arguments);
          }

          return verify$1;
        }()
      }, {
        key: "preSave",
        value: function () {
          var _preSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
            return regeneratorRuntime.wrap(function _callee12$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee12);
          }));

          function preSave() {
            return _preSave.apply(this, arguments);
          }

          return preSave;
        }()
      }, {
        key: "preCreate",
        value: function () {
          var _preCreate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
            return regeneratorRuntime.wrap(function _callee13$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee13);
          }));

          function preCreate() {
            return _preCreate.apply(this, arguments);
          }

          return preCreate;
        }()
      }, {
        key: "preUpdate",
        value: function () {
          var _preUpdate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
            return regeneratorRuntime.wrap(function _callee14$(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee14);
          }));

          function preUpdate() {
            return _preUpdate.apply(this, arguments);
          }

          return preUpdate;
        }()
      }, {
        key: "preDelete",
        value: function () {
          var _preDelete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
            return regeneratorRuntime.wrap(function _callee15$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee15);
          }));

          function preDelete() {
            return _preDelete.apply(this, arguments);
          }

          return preDelete;
        }()
      }, {
        key: "postSave",
        value: function () {
          var _postSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
            return regeneratorRuntime.wrap(function _callee16$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee16);
          }));

          function postSave() {
            return _postSave.apply(this, arguments);
          }

          return postSave;
        }()
      }, {
        key: "postCreate",
        value: function () {
          var _postCreate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
            return regeneratorRuntime.wrap(function _callee17$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee17);
          }));

          function postCreate() {
            return _postCreate.apply(this, arguments);
          }

          return postCreate;
        }()
      }, {
        key: "postUpdate",
        value: function () {
          var _postUpdate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
            return regeneratorRuntime.wrap(function _callee18$(_context19) {
              while (1) {
                switch (_context19.prev = _context19.next) {
                  case 0:
                  case "end":
                    return _context19.stop();
                }
              }
            }, _callee18);
          }));

          function postUpdate() {
            return _postUpdate.apply(this, arguments);
          }

          return postUpdate;
        }()
      }, {
        key: "postDelete",
        value: function () {
          var _postDelete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
            return regeneratorRuntime.wrap(function _callee19$(_context20) {
              while (1) {
                switch (_context20.prev = _context20.next) {
                  case 0:
                  case "end":
                    return _context20.stop();
                }
              }
            }, _callee19);
          }));

          function postDelete() {
            return _postDelete.apply(this, arguments);
          }

          return postDelete;
        }()
      }, {
        key: "_filter",
        value: function () {
          var _filter2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
            var _this = this;

            var _ref7,
                _ref7$incrementA,
                incrementA,
                _ref7$normalize,
                normalize,
                _ref7$resolve,
                resolve,
                _ref7$all,
                all,
                _ref7$evaluator,
                evaluator,
                model,
                _iterator6,
                _step6,
                name,
                exists,
                _args23 = arguments;

            return regeneratorRuntime.wrap(function _callee22$(_context23) {
              while (1) {
                switch (_context23.prev = _context23.next) {
                  case 0:
                    _ref7 = _args23.length > 0 && _args23[0] !== undefined ? _args23[0] : {}, _ref7$incrementA = _ref7.incrementA, incrementA = _ref7$incrementA === void 0 ? true : _ref7$incrementA, _ref7$normalize = _ref7.normalize, normalize = _ref7$normalize === void 0 ? false : _ref7$normalize, _ref7$resolve = _ref7.resolve, resolve = _ref7$resolve === void 0 ? false : _ref7$resolve, _ref7$all = _ref7.all, all = _ref7$all === void 0 ? false : _ref7$all, _ref7$evaluator = _ref7.evaluator, evaluator = _ref7$evaluator === void 0 ? "jsonV" : _ref7$evaluator;
                    model = {}; // iterates over each of the fields that are meant to have its value
                    // increment and performs the appropriate operation taking into account
                    // if the value is already populated or not

                    _iterator6 = _createForOfIteratorHelper(this.constructor.increments);
                    _context23.prev = 3;

                    _iterator6.s();

                  case 5:
                    if ((_step6 = _iterator6.n()).done) {
                      _context23.next = 21;
                      break;
                    }

                    name = _step6.value;

                    if (!(incrementA === false)) {
                      _context23.next = 9;
                      break;
                    }

                    return _context23.abrupt("continue", 19);

                  case 9:
                    exists = this.model[name] !== undefined;

                    if (!exists) {
                      _context23.next = 16;
                      break;
                    }

                    _context23.next = 13;
                    return this.constructor._ensureMin(name, this.model[name]);

                  case 13:
                    model[name] = _context23.sent;
                    _context23.next = 19;
                    break;

                  case 16:
                    _context23.next = 18;
                    return this.constructor._increment(name);

                  case 18:
                    model[name] = _context23.sent;

                  case 19:
                    _context23.next = 5;
                    break;

                  case 21:
                    _context23.next = 26;
                    break;

                  case 23:
                    _context23.prev = 23;
                    _context23.t0 = _context23["catch"](3);

                    _iterator6.e(_context23.t0);

                  case 26:
                    _context23.prev = 26;

                    _iterator6.f();

                    return _context23.finish(26);

                  case 29:
                    _context23.next = 31;
                    return Promise.all(Object.entries(this.model).map( /*#__PURE__*/function () {
                      var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(_ref8) {
                        var _ref10, name, value;

                        return regeneratorRuntime.wrap(function _callee20$(_context21) {
                          while (1) {
                            switch (_context21.prev = _context21.next) {
                              case 0:
                                _ref10 = _slicedToArray(_ref8, 2), name = _ref10[0], value = _ref10[1];

                                if (!(_this.constructor.schema[name] === undefined)) {
                                  _context21.next = 3;
                                  break;
                                }

                                return _context21.abrupt("return");

                              case 3:
                                _context21.next = 5;
                                return _this._evaluate(name, value, evaluator);

                              case 5:
                                model[name] = _context21.sent;

                              case 6:
                              case "end":
                                return _context21.stop();
                            }
                          }
                        }, _callee20);
                      }));

                      return function (_x6) {
                        return _ref9.apply(this, arguments);
                      };
                    }()));

                  case 31:
                    if (!normalize) {
                      _context23.next = 34;
                      break;
                    }

                    _context23.next = 34;
                    return Promise.all(Object.entries(this.model).map( /*#__PURE__*/function () {
                      var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(_ref11) {
                        var _ref13, name, value;

                        return regeneratorRuntime.wrap(function _callee21$(_context22) {
                          while (1) {
                            switch (_context22.prev = _context22.next) {
                              case 0:
                                _ref13 = _slicedToArray(_ref11, 2), name = _ref13[0], value = _ref13[1];

                                if (!(_this.constructor.schema[name] === undefined)) {
                                  _context22.next = 3;
                                  break;
                                }

                                return _context22.abrupt("return");

                              case 3:
                                if (!(!value || !value.refV)) {
                                  _context22.next = 5;
                                  break;
                                }

                                return _context22.abrupt("return");

                              case 5:
                                _context22.next = 7;
                                return value.refV();

                              case 7:
                                model[name] = _context22.sent;

                              case 8:
                              case "end":
                                return _context22.stop();
                            }
                          }
                        }, _callee21);
                      }));

                      return function (_x7) {
                        return _ref12.apply(this, arguments);
                      };
                    }()));

                  case 34:
                    if (!resolve) {
                      _context23.next = 36;
                      break;
                    }

                    throw new NotImplementedError("'resolve' not implemented");

                  case 36:
                    if (!all) {
                      _context23.next = 38;
                      break;
                    }

                    throw new NotImplementedError("'all' not implemented");

                  case 38:
                    return _context23.abrupt("return", model);

                  case 39:
                  case "end":
                    return _context23.stop();
                }
              }
            }, _callee22, this, [[3, 23, 26, 29]]);
          }));

          function _filter() {
            return _filter2.apply(this, arguments);
          }

          return _filter;
        }()
      }, {
        key: "_evaluate",
        value: function () {
          var _evaluate2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(name, value) {
            var _this2 = this;

            var evaluator,
                isIterable,
                hasEvaluator,
                result,
                isModel,
                meta,
                type,
                _name,
                method,
                _args24 = arguments;

            return regeneratorRuntime.wrap(function _callee23$(_context24) {
              while (1) {
                switch (_context24.prev = _context24.next) {
                  case 0:
                    evaluator = _args24.length > 2 && _args24[2] !== undefined ? _args24[2] : "jsonV";
                    _context24.prev = 1;
                    isIterable = Boolean(value && value.items || Array.isArray(value));
                    _context24.next = 10;
                    break;

                  case 5:
                    _context24.prev = 5;
                    _context24.t0 = _context24["catch"](1);

                    if (_context24.t0 instanceof AttributeError) {
                      _context24.next = 9;
                      break;
                    }

                    throw _context24.t0;

                  case 9:
                    isIterable = false;

                  case 10:
                    hasEvaluator = Boolean(evaluator && (Array.isArray(value) ? value.length : value) && value[evaluator]);
                    isIterable = isIterable && !hasEvaluator;

                    if (!isIterable) {
                      _context24.next = 17;
                      break;
                    }

                    _context24.next = 15;
                    return Promise.all((value.items || value).map(function (item) {
                      return _this2._evaluate(name, item, evaluator);
                    }));

                  case 15:
                    result = _context24.sent;
                    return _context24.abrupt("return", result);

                  case 17:
                    // verifies the current value's class is sub class of the model
                    // class and in case it's extracts the relation name from the
                    // value and sets it as the value in iteration
                    isModel = value instanceof Model;

                    if (isModel) {
                      meta = this.constructor.definitionN(name);
                      type = meta.type || String;
                      _name = type._name;
                      value = value[_name];
                    } // iterates over all the values and retrieves the map value for
                    // each of them in case the value contains a map value retrieval
                    // method otherwise uses the normal value returning it to the caller


                    method = hasEvaluator ? value[evaluator] : null;

                    if (!method) {
                      _context24.next = 26;
                      break;
                    }

                    _context24.next = 23;
                    return method.bind(value)(false);

                  case 23:
                    _context24.t1 = _context24.sent;
                    _context24.next = 27;
                    break;

                  case 26:
                    _context24.t1 = value;

                  case 27:
                    value = _context24.t1;
                    return _context24.abrupt("return", value);

                  case 29:
                  case "end":
                    return _context24.stop();
                }
              }
            }, _callee23, this, [[1, 5]]);
          }));

          function _evaluate(_x8, _x9) {
            return _evaluate2.apply(this, arguments);
          }

          return _evaluate;
        }()
      }, {
        key: "getIdentifier",
        value: function getIdentifier(model) {
          return model[this.constructor.idName];
        }
      }, {
        key: "identifier",
        get: function get() {
          return this.getIdentifier(this.model);
        }
      }], [{
        key: "_getAttrs",
        value: function _getAttrs(params, attrs) {
          var _attrs = [];
          attrs.forEach(function (_ref14) {
            var _ref15 = _slicedToArray(_ref14, 2),
                attr = _ref15[0],
                value = _ref15[1];

            if (params[attr] === undefined) {
              _attrs.push(value);

              return;
            }

            var _value = params[attr];
            delete params[attr];

            _attrs.push(_value);
          });
          return _attrs;
        }
      }, {
        key: "get",
        value: function () {
          var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
            var params,
                _this$_getAttrs,
                _this$_getAttrs2,
                eager,
                eagerL,
                map,
                skip,
                limit,
                sort,
                raiseE,
                sortObject,
                found,
                message,
                model,
                _args25 = arguments;

            return regeneratorRuntime.wrap(function _callee24$(_context25) {
              while (1) {
                switch (_context25.prev = _context25.next) {
                  case 0:
                    params = _args25.length > 0 && _args25[0] !== undefined ? _args25[0] : {};

                    /* eslint-disable no-unused-vars */
                    _this$_getAttrs = this._getAttrs(params, [["fields", null], ["eager", null], ["eagerL", null], ["map", false], ["rules", true], ["meta", false], ["build", true], ["fill", true], ["resolveA", null], ["skip", 0], ["limit", 0], ["sort", null], ["raiseE", true]]), _this$_getAttrs2 = _slicedToArray(_this$_getAttrs, 13), eager = _this$_getAttrs2[1], eagerL = _this$_getAttrs2[2], map = _this$_getAttrs2[3], skip = _this$_getAttrs2[9], limit = _this$_getAttrs2[10], sort = _this$_getAttrs2[11], raiseE = _this$_getAttrs2[12];
                    /* eslint-enable no-unused-vars */

                    if (eagerL === null) eagerL = map;
                    if (eagerL) eager = this._eagerB(eager);
                    sortObject = {};

                    if (sort) {
                      sort.forEach(function (_ref16) {
                        var _ref17 = _slicedToArray(_ref16, 2),
                            key = _ref17[0],
                            value = _ref17[1];

                        return sortObject[key] = value;
                      });
                    }

                    _context25.next = 8;
                    return this.collection.findOne(params, this.fields, {
                      skip: skip,
                      limit: limit,
                      sort: sortObject
                    });

                  case 8:
                    found = _context25.sent;

                    if (!(!found && raiseE)) {
                      _context25.next = 12;
                      break;
                    }

                    if (_isDevel()) {
                      message = "".concat(this.name, " not found for ").concat(JSON.stringify(params));
                    } else {
                      message = "".concat(this.name, " not found");
                    }

                    throw new NotFoundError(message);

                  case 12:
                    if (!found) {
                      _context25.next = 18;
                      break;
                    }

                    _context25.next = 15;
                    return new this().wrap(found);

                  case 15:
                    _context25.t0 = _context25.sent;
                    _context25.next = 19;
                    break;

                  case 18:
                    _context25.t0 = found;

                  case 19:
                    model = _context25.t0;

                    if (!model) {
                      _context25.next = 25;
                      break;
                    }

                    if (!eager) {
                      _context25.next = 25;
                      break;
                    }

                    _context25.next = 24;
                    return this._eager(model, eager, {
                      map: map
                    });

                  case 24:
                    model = _context25.sent;

                  case 25:
                    return _context25.abrupt("return", model);

                  case 26:
                  case "end":
                    return _context25.stop();
                }
              }
            }, _callee24, this);
          }));

          function get() {
            return _get.apply(this, arguments);
          }

          return get;
        }()
      }, {
        key: "find",
        value: function () {
          var _find = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25() {
            var _this3 = this;

            var params,
                _this$_getAttrs3,
                _this$_getAttrs4,
                skip,
                limit,
                sort,
                raiseE,
                sortObject,
                found,
                message,
                models,
                _args26 = arguments;

            return regeneratorRuntime.wrap(function _callee25$(_context26) {
              while (1) {
                switch (_context26.prev = _context26.next) {
                  case 0:
                    params = _args26.length > 0 && _args26[0] !== undefined ? _args26[0] : {};

                    /* eslint-disable no-unused-vars */
                    _this$_getAttrs3 = this._getAttrs(params, [["fields", null], ["eager", null], ["eagerL", null], ["map", false], ["rules", true], ["meta", false], ["build", true], ["fill", true], ["resolveA", null], ["skip", 0], ["limit", 0], ["sort", null], ["raiseE", false]]), _this$_getAttrs4 = _slicedToArray(_this$_getAttrs3, 13), skip = _this$_getAttrs4[9], limit = _this$_getAttrs4[10], sort = _this$_getAttrs4[11], raiseE = _this$_getAttrs4[12];
                    /* eslint-enable no-unused-vars */

                    this._findS(params);

                    this._findD(params);

                    sortObject = {};

                    if (sort) {
                      sort.forEach(function (_ref18) {
                        var _ref19 = _slicedToArray(_ref18, 2),
                            key = _ref19[0],
                            value = _ref19[1];

                        return sortObject[key] = value;
                      });
                    }

                    _context26.next = 8;
                    return this.collection.find(params, this.fields, {
                      skip: skip,
                      limit: limit,
                      sort: sortObject
                    });

                  case 8:
                    found = _context26.sent;

                    if (!(found.length === 0 && raiseE)) {
                      _context26.next = 12;
                      break;
                    }

                    if (_isDevel()) {
                      message = "".concat(this.name, " not found for ").concat(JSON.stringify(params));
                    } else {
                      message = "".concat(this.name, " not found");
                    }

                    throw new NotFoundError(message);

                  case 12:
                    _context26.next = 14;
                    return Promise.all(found.map(function (v) {
                      return new _this3().wrap(v);
                    }));

                  case 14:
                    models = _context26.sent;
                    return _context26.abrupt("return", models);

                  case 16:
                  case "end":
                    return _context26.stop();
                }
              }
            }, _callee25, this);
          }));

          function find() {
            return _find.apply(this, arguments);
          }

          return find;
        }()
      }, {
        key: "count",
        value: function () {
          var _count = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26() {
            var params,
                result,
                _args27 = arguments;
            return regeneratorRuntime.wrap(function _callee26$(_context27) {
              while (1) {
                switch (_context27.prev = _context27.next) {
                  case 0:
                    params = _args27.length > 0 && _args27[0] !== undefined ? _args27[0] : {};
                    result = null;

                    if (!(Object.keys(params).length > 0)) {
                      _context27.next = 9;
                      break;
                    }

                    _context27.next = 5;
                    return this.collection.find(params);

                  case 5:
                    result = _context27.sent;
                    result = result.length;
                    _context27.next = 12;
                    break;

                  case 9:
                    _context27.next = 11;
                    return this.collection.count();

                  case 11:
                    result = _context27.sent;

                  case 12:
                    return _context27.abrupt("return", result);

                  case 13:
                  case "end":
                    return _context27.stop();
                }
              }
            }, _callee26, this);
          }));

          function count() {
            return _count.apply(this, arguments);
          }

          return count;
        }()
      }, {
        key: "_findD",
        value: function _findD(params) {
          // retrieves the find definition into a local variable, then
          // removes the find definition from the named arguments map
          // so that it's not going to be erroneously used by the
          // underlying find infra-structure
          var findD = params.find_d;
          delete params.find_d; // in case the find definition is currently not defined in the
          // named arguments map returns immediately as nothing is
          // meant to be done on this method

          if (!findD) return; // tries to retrieve the value of the operator that is going
          // to be used to "join" the multiple find parts (find values)

          var findO = params.find_o;
          delete params.find_o; // verifies that the data type for the find definition is a
          // valid sequence and in case its not converts it into one
          // so that it may be used in sequence valid logic

          var _findD = Array.isArray(findD) ? findD : [findD]; // iterates over all the filters defined in the filter definition
          // so that they may be used to update the provided arguments with
          // the filter defined in each of their lines


          var _iterator7 = _createForOfIteratorHelper(_findD),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var filter = _step7.value;
              // in case the filter is not valid (unset or invalid) it's going
              // to be ignored as no valid information is present
              if (!filter) continue; // splits the filter string into its three main components
              // the name, operator and value, that are going to be processed
              // as defined by the specification to create the filter

              var result = filter.split(":", 3);
              if (result.length === 2) result.push(null); // unpacks the result into it's thee components name, operator
              // and value to be used in the parsing of the filter

              var _result = _slicedToArray(result, 3),
                  name = _result[0],
                  operator = _result[1],
                  value = _result[2]; // retrieves the definition for the filter attribute and uses
              // it to retrieve it's target data type that is going to be
              // used for the proper conversion, note that in case the base
              // type resolution method exists it's used (recursive resolution)


              var nameDefinition = this.definitionN(name);
              var nameT = nameDefinition._btype || nameDefinition.type || String; // determines if the current filter operation should be performed
              // using a case insensitive based approach to the search, by default
              // all of the operations are considered to be case sensitive

              var insensitive = INSENSITIVE[operator] || false; // retrieves the method that is going to be used for value mapping
              // or conversion based on the current operator and then converts
              // the operator into the domain specific operator

              var valueMethod = VALUE_METHODS[operator];

              var _operator = OPERATORS[operator] === undefined ? operator : OPERATORS[operator]; // in case there's a custom value mapped retrieved uses it to convert
              // the string based value into the target specific value for the query
              // otherwise uses the data type for the search field for value conversion


              var _value = valueMethod ? valueMethod(value, nameT) : nameT(value); // constructs the custom find value using a key and value map value
              // in case the operator is defined otherwise (operator not defined)
              // the value is used directly, then merges this find value into the
              // current set of filters for the provided (keyword) arguments


              var findV = void 0;

              if (_operator) {
                var obj = {};
                obj[_operator] = _value;
                findV = obj;
              } else {
                findV = _value;
              }

              if (insensitive) findV.$options = "-i";

              this._filterMerge(name, findV, params, findO);
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        }
        /**
         * Working at a model map/dictionary level tries to resolve the
         * relations described by the sequence of `.` separated names paths.
         *
         * Should be able to handle both instance and map associated eager
         * loading relations.
         *
         * @param {Object} model The model map to be used as reference for the eager
         * loading of relations.
         * @param {Array} names The list of dot separated name paths to "guide" the
         * loading of relations (references).
         * @returns {Object} The resulting model with the required relations loaded.
         */

      }, {
        key: "_eager",
        value: function () {
          var _eager2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(model, names) {
            var _this4 = this;

            var kwargs,
                isList,
                _iterator8,
                _step8,
                name,
                _model,
                _iterator9,
                _step9,
                _loop,
                _ret,
                _args29 = arguments;

            return regeneratorRuntime.wrap(function _callee27$(_context29) {
              while (1) {
                switch (_context29.prev = _context29.next) {
                  case 0:
                    kwargs = _args29.length > 2 && _args29[2] !== undefined ? _args29[2] : {};
                    // verifies if the provided model instance is a sequence and if
                    // that's the case runs the recursive eager loading of names and
                    // returns the resulting sequence to the caller method
                    isList = Array.isArray(model);

                    if (!isList) {
                      _context29.next = 4;
                      break;
                    }

                    return _context29.abrupt("return", Promise.all(model.map(function (_model) {
                      return _this4._eager(_model, names, kwargs);
                    })));

                  case 4:
                    // iterates over the complete set of names that are meant to be
                    // eager loaded from the model and runs the "resolution" process
                    // for each of them so that they are properly eager loaded
                    _iterator8 = _createForOfIteratorHelper(names);
                    _context29.prev = 5;

                    _iterator8.s();

                  case 7:
                    if ((_step8 = _iterator8.n()).done) {
                      _context29.next = 31;
                      break;
                    }

                    name = _step8.value;
                    _model = model;
                    _iterator9 = _createForOfIteratorHelper(name.split("."));
                    _context29.prev = 11;
                    _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                      var part, isSequence;
                      return regeneratorRuntime.wrap(function _loop$(_context28) {
                        while (1) {
                          switch (_context28.prev = _context28.next) {
                            case 0:
                              part = _step9.value;
                              isSequence = Array.isArray(_model);

                              if (!isSequence) {
                                _context28.next = 8;
                                break;
                              }

                              _context28.next = 5;
                              return Promise.all(_model.map(function (value) {
                                return _this4._res(value, part, kwargs);
                              }));

                            case 5:
                              _model = _context28.sent;
                              _context28.next = 11;
                              break;

                            case 8:
                              _context28.next = 10;
                              return _this4._res(_model, part, kwargs);

                            case 10:
                              _model = _context28.sent;

                            case 11:
                              if (_model) {
                                _context28.next = 13;
                                break;
                              }

                              return _context28.abrupt("return", "break");

                            case 13:
                            case "end":
                              return _context28.stop();
                          }
                        }
                      }, _loop);
                    });

                    _iterator9.s();

                  case 14:
                    if ((_step9 = _iterator9.n()).done) {
                      _context29.next = 21;
                      break;
                    }

                    return _context29.delegateYield(_loop(), "t0", 16);

                  case 16:
                    _ret = _context29.t0;

                    if (!(_ret === "break")) {
                      _context29.next = 19;
                      break;
                    }

                    return _context29.abrupt("break", 21);

                  case 19:
                    _context29.next = 14;
                    break;

                  case 21:
                    _context29.next = 26;
                    break;

                  case 23:
                    _context29.prev = 23;
                    _context29.t1 = _context29["catch"](11);

                    _iterator9.e(_context29.t1);

                  case 26:
                    _context29.prev = 26;

                    _iterator9.f();

                    return _context29.finish(26);

                  case 29:
                    _context29.next = 7;
                    break;

                  case 31:
                    _context29.next = 36;
                    break;

                  case 33:
                    _context29.prev = 33;
                    _context29.t2 = _context29["catch"](5);

                    _iterator8.e(_context29.t2);

                  case 36:
                    _context29.prev = 36;

                    _iterator8.f();

                    return _context29.finish(36);

                  case 39:
                    return _context29.abrupt("return", model);

                  case 40:
                  case "end":
                    return _context29.stop();
                }
              }
            }, _callee27, null, [[5, 33, 36, 39], [11, 23, 26, 29]]);
          }));

          function _eager(_x10, _x11) {
            return _eager2.apply(this, arguments);
          }

          return _eager;
        }()
        /**
         * Resolves a specific model part taking into account the multiple
         * possible resolution strategies.
         *
         * Most of its logic will be associated with reference like types.
         *
         * This method will also (for map based resolution strategies) change
         * the owner model, setting its references with the resolved maps, this
         * is required as maps do not allow reference objects to exist.
         *
         * @param {Object} model The model map to be used in the resolution process.
         * @param {String} part The name of the model's part to be resolved.
         * @returns {Object} The resolved part that may be either a map or an object
         * depending on the resolution strategy.
         */

      }, {
        key: "_res",
        value: function () {
          var _res2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(model, part) {
            var kwargs,
                value,
                isReference,
                _args30 = arguments;
            return regeneratorRuntime.wrap(function _callee28$(_context30) {
              while (1) {
                switch (_context30.prev = _context30.next) {
                  case 0:
                    kwargs = _args30.length > 2 && _args30[2] !== undefined ? _args30[2] : {};

                    if (model) {
                      _context30.next = 3;
                      break;
                    }

                    return _context30.abrupt("return", model);

                  case 3:
                    value = model[part]; // check the data type of the requested name for resolution
                    // and in case it's not valid and not a reference returns it
                    // immediately, no resolution to be performed

                    isReference = TYPE_REFERENCES.some(function (type) {
                      return value instanceof type;
                    });

                    if (!(!value && !isReference)) {
                      _context30.next = 7;
                      break;
                    }

                    return _context30.abrupt("return", value);

                  case 7:
                    if (!isReference) {
                      _context30.next = 11;
                      break;
                    }

                    _context30.next = 10;
                    return value.resolve({
                      eagerL: true
                    });

                  case 10:
                    value = _context30.sent;

                  case 11:
                    // in case the map resolution process was requested an explicit
                    // set of the resolved value is required (implicit resolution
                    // using `resolve()`) is not enough to ensure proper type structure
                    if (kwargs.map) model[part] = value; // returns the "final" (possibly resolved) value to the caller method
                    // ready to be used for possible merging processes

                    return _context30.abrupt("return", value);

                  case 13:
                  case "end":
                    return _context30.stop();
                }
              }
            }, _callee28);
          }));

          function _res(_x12, _x13) {
            return _res2.apply(this, arguments);
          }

          return _res;
        }()
      }, {
        key: "_findS",
        value: function _findS(params) {
          // tries to retrieve the find name value from the provided
          // named arguments defaulting to an unset value otherwise
          var findN = params.find_n;
          delete params.find_n; // retrieves the kind of insensitive strategy that is going
          // to be used for the resolution of regular expressions,
          // this should affect all the filters and so it should be
          // used with some amount of care

          var findI = params.find_i || false;
          delete params.find_i; // retrieves the kind of default operation to be performed
          // this may be either: right, left or both and the default
          // value is both so that the token is matched in case it
          // appears anywhere in the search string

          var findT = params.find_t || "both";
          delete params.find_t; // retrieves the find string into a local variable, then
          // removes the find string from the named arguments map
          // so that it's not going to be erroneously used by the
          // underlying find infra-structure

          var findS = params.find_s;
          delete params.find_s; // in case the find string is currently not defined in the
          // named arguments map returns immediately as nothing is
          // meant to be done on this method

          if (!findS) return; // retrieves the "name" of the attribute that is considered
          // to be the default (representation) for the model in case
          // there's none returns immediately, as it's not possible
          // to proceed with the filter creation

          var defaultName = findN || this["default"]; // TODO DEFAULT WORKS?

          if (!defaultName) return; // constructs the proper right and left parts of the regex
          // that is going to be constructed for the matching of the
          // value, this is achieved by checking the find type

          var right = findT === "right" ? "^" : "";
          var left = findT === "left" ? "$" : ""; // retrieves the definition for the default attribute and uses
          // it to retrieve it's target data type, defaulting to the
          // string type in case none is defined in the schema

          var defaultT = this.definitionN(defaultName).type || String;
          var findV;

          try {
            // in case the target date type for the default field is
            // string the both sides wildcard regex is used for the
            // search
            if (defaultT === String) {
              findV = {
                $regex: right + escapeStringRegexp(findS) + left,
                $options: findI ? "-i" : ""
              };
            } else {
              findV = null;
            }
          } catch (err) {
            // in case there's an error in the conversion for
            // the target type value sets the search value as
            // invalid (not going to be used in filter)
            findV = null;
          }

          if (findV) this._filterMerge(defaultName, findV, params);
        }
      }, {
        key: "fields",
        get: function get() {
          return Object.keys(this.schema);
        }
      }, {
        key: "default",
        get: function get() {
          var defaultEntry = Object.entries(this.schema).find(function (_ref20) {
            var _ref21 = _slicedToArray(_ref20, 2);
                _ref21[0];
                var definition = _ref21[1];

            return definition["default"];
          });
          return defaultEntry ? defaultEntry[0] : null;
        }
      }, {
        key: "definitionN",
        value: function definitionN(name) {
          return this.schema[name] || {};
        }
      }, {
        key: "_filterMerge",
        value: function _filterMerge(name, filter, params) {
          var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          // retrieves a possible previous filter defined for the
          // provided name in case it does exist must concatenate
          // that previous value in a join statement according to
          // the currently defined operator
          var filterP = params[name];

          if (filterP || operator) {
            // defaults the operator for the join of the names to the
            // value and then ensures that the value of the operator
            // is within a valid range of values
            var _operator = operator || "$and";

            verify(["$and", "$or"].includes(_operator)); // retrieves the and references for the current arguments
            // and appends the two filter values (current and previous)
            // then deletes the current name reference in the arguments
            // and updates the name value to the and value


            var filterA = params[_operator] || []; // builds the filter object assigned to the name of the
            // variable and adds to the list of values

            var _filter = {};
            _filter[name] = filter;
            filterA.push(_filter); // in case there's a previous filter also adds it to the
            // list of filter values

            if (filterP) {
              var _filterP = {};
              _filterP[name] = filterP;
              filterA.push(_filterP);
            } // updates the filter reference and updates the operator
            // name (as expected)


            filter = filterA;
            delete params[name];
            name = _operator;
          } // sets the currently defined filter structures in the keyword
          // based arguments map for the currently defined name


          params[name] = filter;
        }
      }, {
        key: "schema",
        get: function get() {
          throw new NotImplementedError();
        }
        /**
         * Safer version of the schema structure that filters
         * some of the field attributes making it suitable to
         * be used by some of the collection adapters.
         */

      }, {
        key: "schemaSafe",
        get: function get() {
          var schema = {};

          for (var _i5 = 0, _Object$entries4 = Object.entries(this.schema); _i5 < _Object$entries4.length; _i5++) {
            var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i5], 2),
                key = _Object$entries4$_i[0],
                value = _Object$entries4$_i[1];

            schema[key] = {
              type: value.type || String,
              index: value.index || false
            };
          }

          return schema;
        }
      }, {
        key: "collection",
        get: function get() {
          if (this._collectionI) return this._collectionI;
          this._collectionI = this._collection(this.dataOptions);
          return this._collectionI;
        }
      }, {
        key: "idName",
        get: function get() {
          return "id";
        }
      }, {
        key: "dataOptions",
        get: function get() {
          return {
            name: this.name,
            schema: this.schemaSafe
          };
        }
      }, {
        key: "increments",
        get: function get() {
          if (this._increments !== undefined) return this._increments;
          var increments = [];

          for (var _i6 = 0, _Object$entries5 = Object.entries(this.schema); _i6 < _Object$entries5.length; _i6++) {
            var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i6], 2),
                name = _Object$entries5$_i[0],
                value = _Object$entries5$_i[1];

            var isIncrement = value.increment || false;
            if (!isIncrement) continue;
            increments.push(name);
          }

          this._increments = increments;
          return increments;
        }
      }, {
        key: "_collection",
        value: function _collection(options) {
          var adapter = this.adapter[0].toUpperCase() + this.adapter.slice(1);
          return new collection[adapter + "Collection"](options);
        }
      }, {
        key: "_increment",
        value: function () {
          var _increment2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(name) {
            var _name, store, result;

            return regeneratorRuntime.wrap(function _callee29$(_context31) {
              while (1) {
                switch (_context31.prev = _context31.next) {
                  case 0:
                    _name = this.name + ":" + name;
                    store = this._collection({
                      name: "counters",
                      schema: {
                        id: {
                          type: String,
                          index: true
                        },
                        seq: {
                          type: Number
                        }
                      }
                    });
                    _context31.next = 4;
                    return store.findOneAndUpdate({
                      id: _name
                    }, {
                      $inc: {
                        seq: 1
                      }
                    }, {
                      "new": true,
                      upsert: true
                    });

                  case 4:
                    result = _context31.sent;
                    _context31.t0 = result;

                    if (_context31.t0) {
                      _context31.next = 10;
                      break;
                    }

                    _context31.next = 9;
                    return store.findOne({
                      id: _name
                    });

                  case 9:
                    _context31.t0 = _context31.sent;

                  case 10:
                    result = _context31.t0;
                    return _context31.abrupt("return", result.seq);

                  case 12:
                  case "end":
                    return _context31.stop();
                }
              }
            }, _callee29, this);
          }));

          function _increment(_x14) {
            return _increment2.apply(this, arguments);
          }

          return _increment;
        }()
      }, {
        key: "_ensureMin",
        value: function () {
          var _ensureMin2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(name, value) {
            var _name, store, result;

            return regeneratorRuntime.wrap(function _callee30$(_context32) {
              while (1) {
                switch (_context32.prev = _context32.next) {
                  case 0:
                    _name = this.name + ":" + name;
                    store = this._collection({
                      name: "counters",
                      schema: {
                        id: {
                          type: String
                        },
                        seq: {
                          type: Number
                        }
                      }
                    });
                    _context32.next = 4;
                    return store.findOneAndUpdate({
                      id: _name
                    }, {
                      $max: {
                        seq: value
                      }
                    }, {
                      "new": true,
                      upsert: true
                    });

                  case 4:
                    result = _context32.sent;
                    _context32.t0 = result;

                    if (_context32.t0) {
                      _context32.next = 10;
                      break;
                    }

                    _context32.next = 9;
                    return store.findOne({
                      id: _name
                    });

                  case 9:
                    _context32.t0 = _context32.sent;

                  case 10:
                    result = _context32.t0;
                    return _context32.abrupt("return", result.seq);

                  case 12:
                  case "end":
                    return _context32.stop();
                }
              }
            }, _callee30, this);
          }));

          function _ensureMin(_x15, _x16) {
            return _ensureMin2.apply(this, arguments);
          }

          return _ensureMin;
        }()
        /**
         * Builds the provided list of eager values, preparing them
         * according to the current model rules.
         *
         * The composition process includes the extension of the provided
         * sequence of eager values with the base ones defined in the
         * model, if not handled correctly this is an expensive operation.
         *
         * @param {Array} eager The base sequence containing the various fields
         * that should be eagerly loaded for the operation.
         * @returns {Array} The "final" resolved array that may be used for the eager
         * loaded operation performance.
         */

      }, {
        key: "_eagerB",
        value: function _eagerB(eager) {
          var _eager3;

          eager = eager || [];
          eager = Array.isArray(eager) ? eager : [eager];

          (_eager3 = eager).push.apply(_eager3, _toConsumableArray(this.eagers));

          if (eager.length === 0) return eager;
          eager = _toConsumableArray(new Set(eager));
          return eager;
        }
      }]);

      return ModelStore;
    }(Model);
    var ModelMemory = /*#__PURE__*/function (_ModelStore) {
      _inherits(ModelMemory, _ModelStore);

      var _super2 = _createSuper(ModelMemory);

      function ModelMemory() {
        _classCallCheck(this, ModelMemory);

        return _super2.apply(this, arguments);
      }

      _createClass(ModelMemory, null, [{
        key: "adapter",
        get: function get() {
          return "memory";
        }
      }, {
        key: "dataOptions",
        get: function get() {
          return Object.assign(_get(_getPrototypeOf(ModelMemory), "dataOptions", this), {
            storage: this.storage
          });
        }
      }, {
        key: "storage",
        get: function get() {
          return MEMORY_STORAGE[this.name];
        }
      }]);

      return ModelMemory;
    }(ModelStore);
    /**
     * Retrieves the default (initial) value for the a certain
     * provided data type falling back to the provided default
     * value in case it's not possible to retrieve a new valid
     *  default for value for the type.
     *
     * The process of retrieval of the default value to a certain
     * type may include the calling of a lambda function to obtain
     * a new instance of the default value, this avoid the usage
     * of global shared structures for the default values, that
     * could cause extremely confusing situations.
     *
     * @param {Type} type The data type object for which to retrieve its
     * default value.
     * @param {Object} _default The default value to be returned in case it's
     * not possible to retrieve a better one.
     * @returns {Object} The "final" default value for the data type according
     * to the best possible strategy.
     */

    var typeD = function typeD(type) {
      var _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (TYPE_DEFAULTS[type] === undefined) return _default;
      _default = TYPE_DEFAULTS[type];
      if (typeof _default !== "function") return _default;
      return _default();
    };

    var ensureExpress = function ensureExpress(token) {
      return function (req, res, next) {
        ensurePermissions(token, req)["catch"](next).then(next);
      };
    };

    var yoniusRollup = function yoniusRollup() {
      return {
        name: "yonius",
        resolveId: function resolveId(importee) {
          switch (importee) {
            case "fs":
            case "node-fetch":
              return importee;

            default:
              return null;
          }
        },
        load: function load(id) {
          switch (id) {
            case "fs":
              return "export const promises = {};";

            case "node-fetch":
              return "export default fetch;";

            default:
              return null;
          }
        }
      };
    };

    var NAME = name;
    var VERSION = version;

    exports.ALIAS = ALIAS;
    exports.API = API;
    exports.AttributeError = AttributeError;
    exports.Collection = Collection;
    exports.FIND_DEFAULTS = FIND_DEFAULTS;
    exports.FIND_TYPES = FIND_TYPES;
    exports.FileTuple = FileTuple;
    exports.INSENSITIVE = INSENSITIVE;
    exports.MixinBuilder = MixinBuilder;
    exports.Model = Model;
    exports.ModelMemory = ModelMemory;
    exports.ModelStore = ModelStore;
    exports.MongoCollection = MongoCollection;
    exports.NAME = NAME;
    exports.NotFoundError = NotFoundError;
    exports.NotImplementedError = NotImplementedError;
    exports.OAuth1API = OAuth1API;
    exports.OAuth2API = OAuth2API;
    exports.OAuthAPI = OAuthAPI;
    exports.OPERATORS = OPERATORS;
    exports.Observable = Observable;
    exports.OperationalError = OperationalError;
    exports.Reference = Reference;
    exports.References = References;
    exports.SORT_MAP = SORT_MAP;
    exports.VALUE_METHODS = VALUE_METHODS;
    exports.VERSION = VERSION;
    exports.ValidationError = ValidationError;
    exports.YoniusError = YoniusError;
    exports._castR = _castR;
    exports._isDevel = _isDevel;
    exports._isSecure = _isSecure;
    exports._isValid = _isValid;
    exports.absoluteUrl = absoluteUrl;
    exports.all = all;
    exports.buildGetAgent = buildGetAgent;
    exports.camelToUnderscore = camelToUnderscore;
    exports.conf = conf;
    exports.confP = confP;
    exports.confS = confS;
    exports.destroyMongo = destroyMongo;
    exports.ensureExpress = ensureExpress;
    exports.ensurePermissions = ensurePermissions;
    exports.eq = eq;
    exports.equal = equal;
    exports.escapeStringRegexp = escapeStringRegexp;
    exports.expandUser = expandUser;
    exports.getEnv = getEnv;
    exports.getEnvObject = getEnvObject;
    exports.getObject = getObject;
    exports.globals = globals;
    exports.gt = gt;
    exports.gte = gte;
    exports.hasPermission = hasPermission;
    exports.initMongo = initMongo;
    exports.isEmail = isEmail;
    exports.isIn = isIn;
    exports.isLower = isLower;
    exports.isPrimitive = isPrimitive;
    exports.isRegex = isRegex;
    exports.isSimple = isSimple;
    exports.isUpper = isUpper;
    exports.isUrl = isUrl;
    exports.load = load;
    exports.loadConf = load$1;
    exports.mix = mix;
    exports.notEmpty = notEmpty;
    exports.patchAgent = patchAgent;
    exports.pathExists = pathExists;
    exports.reference = reference;
    exports.references = references;
    exports.register = register;
    exports.request = request;
    exports.sizeRoundUnit = sizeRoundUnit;
    exports.stringEq = stringEq;
    exports.stringGt = stringGt;
    exports.stringLt = stringLt;
    exports.toTokensM = toTokensM;
    exports.typeD = typeD;
    exports.typeof_ = typeof_;
    exports.underscoreToCamel = underscoreToCamel;
    exports.unload = unload;
    exports.unregister = unregister;
    exports.urlEncode = urlEncode;
    exports.verify = verify;
    exports.verifyEqual = verifyEqual;
    exports.verifyMany = verifyMany;
    exports.verifyNotEqual = verifyNotEqual;
    exports.yoniusRollup = yoniusRollup;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=yonius.umd.js.map
