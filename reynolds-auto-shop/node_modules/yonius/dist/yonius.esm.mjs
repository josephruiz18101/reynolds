/**
 * Yonius 0.11.7.
 *
 * Copyright (c) 2008-2022 Hive Solutions Lda.
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import * as fs from 'fs';
import { join, normalize, resolve, dirname } from 'path';
import { env } from 'process';
import fetch from 'node-fetch';

var name = "yonius";
var version = "0.11.7";

class Observable {
    constructor() {
        this.callbacks = {};
    }

    bind(event, callback) {
        const callbacks = this.callbacks[event] || [];
        callbacks.push(callback);
        this.callbacks[event] = callbacks;
        return callback;
    }

    unbind(event, callback) {
        const callbacks = this.callbacks[event] || [];
        if (!callback) {
            delete this.callbacks[event];
            return;
        }

        const index = callbacks.indexOf(callback);
        if (index === -1) {
            return;
        }
        callbacks.splice(index, 1);
        this.callbacks[event] = callbacks;
    }

    trigger(event) {
        const callbacks = this.callbacks[event] || [];
        const results = [];
        for (const callback of callbacks) {
            const result = callback.apply(this, Array.prototype.slice.call(arguments, 1));
            result !== undefined && result !== null && results.push(result);
        }
        return Promise.all(results);
    }
}

const verify = function(
    condition,
    message = null,
    code = null,
    exception = null,
    kwargs = {},
    safeKeys = ["message"]
) {
    if (condition) return;
    message = message || "Verification failed";
    const Exception = exception || Error;
    kwargs = Object.assign({}, kwargs);
    if (message !== null && message !== undefined) kwargs.message = message;
    if (code !== null && message !== undefined) kwargs.code = code;
    const throwable = new Exception(kwargs.message || undefined);
    throwable.kwargs = kwargs;
    for (const [key, value] of Object.entries(kwargs)) {
        if (safeKeys.includes(key) && throwable[key] !== undefined) {
            continue;
        }
        throwable[key] = value;
    }
    throw throwable;
};

const verifyEqual = function(
    first,
    second,
    message = null,
    code = null,
    exception = null,
    kwargs = {}
) {
    message = message || `Expected ${first} got ${second}`;
    return this.verify(first === second, message, code, exception, kwargs);
};

const verifyNotEqual = function(
    first,
    second,
    message = null,
    code = null,
    exception = null,
    kwargs = {}
) {
    message = message || `Expected ${first} not equal to ${second}`;
    return this.verify(first !== second, message, code, exception, kwargs);
};

const verifyMany = function(
    sequence,
    message = null,
    code = null,
    exception = null,
    kwargs = {}
) {
    sequence.forEach(element => {
        verify(element, message, code, exception, kwargs);
    });
};

let HOME_DIR = null;

const pathExists = async function(path) {
    try {
        await fs.promises.access(path);
    } catch (error) {
        return false;
    }
    return true;
};

const expandUser = function(path) {
    if (!path) return path;
    if (path === "~") return _homeDir();
    if (path.slice(0, 2) !== "~/") return path;
    return join(HOME_DIR, path.slice(2));
};

const getEnv = function(name) {
    // eslint-disable-next-line no-undef
    if (typeof Deno !== "undefined") return Deno.env.get(name);
    return env[name];
};

const getEnvObject = function() {
    // eslint-disable-next-line no-undef
    if (typeof Deno !== "undefined") return Deno.env.toObject();
    return env;
};

const _homeDir = function() {
    if (HOME_DIR !== null) return HOME_DIR;
    const isWindows = Boolean(typeof process !== "undefined" && process.platform === "win32");
    HOME_DIR = getEnv(isWindows ? "USERPROFILE" : "HOME") || "/";
    return HOME_DIR;
};

const FILE_NAME = "yonius.json";

const HOME_FILE = "~/.home";

const IMPORT_NAMES = ["$import", "$include", "$IMPORT", "$INCLUDE"];

const CASTS = {
    int: v => (typeof v === "number" ? v : parseInt(v)),
    float: v => (typeof v === "number" ? v : parseFloat(v)),
    bool: v => (typeof v === "boolean" ? v : ["1", "true", "True"].includes(v)),
    list: v => (Array.isArray(v) ? v : v.split(";")),
    tuple: v => (Array.isArray(v) ? v : v.split(";"))
};

const globals =
    typeof global === "undefined"
        ? typeof window === "undefined"
            ? typeof self === "undefined"
                ? {}
                : self
            : window
        : global;

globals.CONFIGS = globals.CONFIGS === undefined ? {} : globals.CONFIGS;

globals.CONFIG_F = globals.CONFIG_F === undefined ? [] : globals.CONFIG_F;

globals.HOMES = globals.HOMES === undefined ? [] : globals.HOMES;

globals.LOADED = globals.LOADED === undefined ? false : globals.LOADED;

const conf = function(name, fallback = undefined, cast = null, ctx = null) {
    const configs = ctx ? ctx.configs : globals.CONFIGS;
    cast = _castR(cast);
    let value = configs[name] === undefined ? fallback : configs[name];
    if (cast && value !== undefined && value !== null) value = cast(value);
    return value;
};

const confP = async function(name, fallback = undefined, cast = null, ctx = null) {
    await load$1();
    return conf(name, fallback, cast, ctx);
};

const confS = function(name, value, ctx = null) {
    const configs = ctx ? ctx.configs : globals.CONFIGS;
    configs[name] = value;
};

const load$1 = async function(
    names = [FILE_NAME],
    path = null,
    encoding = "utf-8",
    force = false,
    ctx = null
) {
    if (globals.LOADED && !force) return;
    let paths = [];
    const homes = await getHomes();
    for (const home of homes) {
        paths = paths.concat([join(home), join(home, ".config")]);
    }
    paths.push(path);
    for (const path of paths) {
        for (const name of names) {
            await loadFile(name, path, encoding, ctx);
        }
    }
    await loadEnv(ctx);
    globals.LOADED = true;
};

const loadFile = async function(
    name = FILE_NAME,
    path = null,
    encoding = "utf-8",
    ctx = null
) {
    const configs = ctx ? ctx.configs : globals.CONFIGS;
    const configF = ctx ? ctx.configF : globals.CONFIG_F;

    let key;
    let value;
    let exists;
    let filePath;

    if (path) path = normalize(path);
    if (path) filePath = join(path, name);
    else filePath = name;

    filePath = resolve(filePath);
    filePath = normalize(filePath);
    const basePath = dirname(filePath);

    exists = await pathExists(filePath);
    if (!exists) return;

    exists = configF.includes(filePath);
    if (exists) configF.splice(configF.indexOf(filePath), 1);
    configF.push(filePath);

    const data = await fs.promises.readFile(filePath, { encoding: encoding });
    const dataJ = JSON.parse(data);

    await _loadIncludes(basePath, dataJ, encoding);

    for ([key, value] of Object.entries(dataJ)) {
        if (!_isValid(key)) continue;
        configs[key] = value;
    }
};

const loadEnv = async function(ctx = null) {
    const env = getEnvObject();
    const configs = ctx ? ctx.configs : globals.CONFIGS;
    if (env === undefined || env === null) return;
    Object.entries(env).forEach(function([key, value]) {
        configs[key] = value;
    });
};

const getHomes = async function(
    filePath = HOME_FILE,
    fallback = "~",
    encoding = "utf-8",
    forceDefault = false
) {
    if (globals.HOMES.length > 0) return globals.HOMES;

    const env = getEnvObject();

    globals.HOMES = env.HOMES === undefined ? null : env.HOMES;
    globals.HOMES = globals.HOMES ? globals.HOMES.split(";") : globals.HOMES;
    if (globals.HOMES !== null) return globals.HOMES;

    fallback = expandUser(fallback);
    fallback = normalize(fallback);
    globals.HOMES = [fallback];

    filePath = expandUser(filePath);
    filePath = normalize(filePath);
    const exists = await pathExists(filePath);
    if (!exists) return globals.HOMES;

    if (!forceDefault) globals.HOMES.splice(0, globals.HOMES.length);

    let data = await fs.promises.readFile(filePath, { encoding: encoding });
    data = data.trim();

    let paths = data.split(/\r?\n/);
    paths = paths.map(v => v.trim());

    for (let path of paths) {
        path = path.trim();
        if (!path) continue;
        path = expandUser(path);
        path = normalize(path);
        globals.HOMES.push(path);
    }

    return globals.HOMES;
};

const _castR = function(cast) {
    return CASTS[cast] === undefined ? cast : CASTS[cast];
};

const _loadIncludes = async function(basePath, config, encoding = "utf-8") {
    let includes = [];

    for (const alias of IMPORT_NAMES) {
        includes = config[alias] === undefined ? includes : config[alias];
    }

    if (typeof includes === "string") {
        includes = includes.split(";");
    }

    for (const include of includes) {
        await loadFile(include, basePath, encoding);
    }
};

const _isValid = function(key) {
    if (IMPORT_NAMES.includes(key)) return false;
    return true;
};

const _isDevel = function() {
    return ["DEBUG"].includes(conf("LEVEL", "INFO"));
};

const _isSecure = function() {
    return conf("SECURE", true, "bool");
};

/**
 * The map containing the various attribute alias between the normalized
 * manned and the Yonius manner.
 */
const ALIAS = {
    context: "find_d",
    filters: "find_d",
    "filters[]": "find_d",
    filter_def: "find_d",
    filter_string: "find_s",
    filter_name: "find_n",
    filter_operator: "find_o",
    insensitive: "find_i",
    order: "sort",
    offset: "skip",
    start_record: "skip",
    number_records: "limit"
};

/**
 * The map associating the various find fields with their respective
 * types, note that in case a special conversion operation is required
 * the associated value may represent a conversion function instead.
 */
const FIND_TYPES = {
    skip: v => parseInt(v),
    limit: v => Math.max(0, parseInt(v)),
    find_s: v => v,
    find_d: v => (Array.isArray(v) ? v : [v]),
    find_i: v => Boolean(v),
    find_t: v => v,
    find_n: v => v,
    find_o: v => v,
    sort: v => _toSort(v),
    meta: v => Boolean(v),
    fields: v => v
};

/**
 * The map that defines the various default values for a series of
 * find related attributes.
 */
const FIND_DEFAULTS = { limit: 10 };

/**
 * The map associating the normalized (text) way of representing sorting
 * with the current infra-structure number way of representing the same
 * information.
 */
const SORT_MAP = {
    1: 1,
    "-1": -1,
    ascending: 1,
    descending: -1
};

const getObject = function(params = {}, options = {}) {
    const { alias = false, page = false, find = false, norm = true } = options;
    let result = params;

    // in case the alias flag is set tries to resolve the attribute alias and
    // in case the find types are set converts the find based attributes using
    // the currently defined mapping map
    if (alias) result = _resolveAlias(result);
    if (page) result = _pageTypes(result);
    if (find) {
        result = _findTypes(result);
        result = _findDefaults(result, options);
    }

    // in case the normalization flag is set runs the normalization of the
    // provided object so that sequences are properly handled as defined in
    // the specification (this allows multiple references)
    if (norm) result = _normParams(result);

    // returns the constructed object to the caller method this object
    // should be a structured representation of the data in the request
    return result;
};

const _resolveAlias = function(params) {
    const result = {};
    Object.entries(params).forEach(([key, value]) => {
        result[ALIAS[key] || key] = value;
    });
    return result;
};

const _pageTypes = function(params, defaultSize = 50) {
    const result = Object.assign({}, params);

    const page = parseInt(params.page || 1);
    const size = parseInt(params.size || defaultSize);
    const offset = page - 1;
    result.skip = offset * size;
    result.limit = size;

    const sorter = params.sorter;
    const direction = params.direction || "descending";
    if (sorter) result.sort = `${sorter}:${direction}`;

    return result;
};

const _toSort = function(value) {
    const values = value.split(":", 2);
    if (values.length === 1) values.push("descending");
    const [name, direction] = values;
    if (name === "default") return null;
    values[1] = SORT_MAP[direction] || 1;
    return [values];
};

const _findTypes = function(params) {
    const result = {};
    Object.entries(params).forEach(([key, value]) => {
        const converter = FIND_TYPES[key];
        const converted = converter ? converter(value) : value;
        result[key] = converted;
    });
    return result;
};

const _findDefaults = function(params, options = {}) {
    const result = Object.assign({}, params);
    Object.entries(options)
        .filter(([key]) => FIND_TYPES[key])
        .forEach(([key, value]) => {
            result[key] = params[key] || value;
        });
    Object.entries(FIND_DEFAULTS).forEach(([key, value]) => {
        result[key] = params[key] || value;
    });
    return result;
};

const _normParams = function(params) {
    const result = Object.assign({}, params);

    // iterates over all the key value association in the object,
    // trying to find the ones that refer sequences so that they
    // may be normalized
    for (const [key, value] of Object.entries(params)) {
        // verifies if the current name references a sequence and
        // if that's not the case continues the loop trying to find
        // any other sequence based value
        if (!key.endsWith("[]")) {
            result[key] = value;
            continue;
        }

        // removes the extra sequence indication value
        const name = key.substring(0, key.length - 2);

        // in case the current value is not valid (empty) the object
        // is set with an empty list for the current iteration as this
        // is considered to be the default value
        if (!value) {
            result[name] = [];
            continue;
        }

        // retrieves the normalized and linearized list of leafs
        // for the current value and ten verifies the size of each
        // of its values and uses it to measure the number of
        // dictionary elements that are going to be contained in
        // the sequence to be "generated", then uses this (size)
        // value to pre-generate the complete set of dictionaries
        const leafs = _leafs(value);
        const [, values] = leafs[0] || [null, []];
        const list = values.map(_ => ({}));

        // sets the list of generates dictionaries in the object for
        // the newly normalized name of structure
        result[name] = list;

        // iterates over the complete set of key value pairs in the
        // leafs list to gather the value into the various objects that
        // are contained in the sequence (normalization process)
        for (const [name, value] of leafs) {
            for (let index; index < list.length; index++) {
                const object = list[index];
                const nameList = name.split(".");
                _setObject(object, nameList, value[index]);
            }
        }
    }

    return result;
};

/**
 * Retrieves a list containing a series of tuples that each represent a
 * leaf of the current object structure. A leaf is the last element of an
 * object that is not a map, the other intermediary maps are considered to
 * be trunks and should be percolated recursively.
 * This is a recursive function that takes some memory for the construction
 * of the list, and so should be used with the proper care to avoid bottlenecks.
 *
 * @param {Object} params The object for which the leafs list structure is
 * meant to be retrieved.
 * @returns {Array} The list of leaf node tuples for the provided object,
 * as requested for each of the sequences.
 */
const _leafs = function(params) {
    // the list that will hold the various leaf nodes "gathered" by
    // the current recursion function
    let result = [];

    // iterates over all the key and value relations in the object trying
    // to find the leaf nodes (no map nodes) creating a tuple of fqn
    // (fully qualified name) and value
    for (const [key, value] of Object.entries(params)) {
        // retrieves the data type for the current value and validation
        // if it is a object or any other type in case it's an object a
        // new iteration step must be performed retrieving the leafs of
        // the value and then incrementing the name with the current prefix
        if (typeof value === "object") {
            const leafs = _leafs(value).map(([name, value]) => [`${key}.${name}`, value]);
            result = Array.concat(result, leafs);
        } else {
            // otherwise this is a leaf node and so the leaf tuple node
            // must be constructed with the current value (properly validated
            // for sequence presence)
            result.push([key, Array.isArray(value) ? value : [value]]);
        }
    }

    return result;
};

/**
 * Sets a composite value in an object, allowing for dynamic setting of
 * random size key values.
 * This method is useful for situations where one wants to set a value
 * at a randomly defined depth inside an object without having to much
 * work with the creation of the inner dictionaries.
 *
 * @param {Object} object The target object that is going to be
 * changed and set with the target value.
 * @param {Array} nameList The list of names that defined the fully
 * qualified name to be used in the setting of the value
 * for example path.to.end will be a three size list containing each
 * of the partial names.
 * @param {Object} value The value that is going to be set in the
 * defined target of the object.
 */
const _setObject = function(object, nameList, value) {
    // retrieves the first name in the names list this is the
    // value that is going to be used for the current iteration
    const [name, ...tail] = nameList[0];

    // in case the length of the current names list has reached
    // one this is the final iteration and so the value is set
    // at the current naming point
    if (nameList.length === 1) {
        object[name] = value;
    } else {
        // otherwise this is a "normal" step and so a new map must
        // be created/retrieved and the iteration step should be
        // performed on this new map as it's set on the current naming
        // place (recursion step)

        const map = object[name] || {};
        object[name] = map;
        _setObject(map, tail, value);
    }
};

class MixinBuilder {
    constructor(superclass) {
        this.superclass = superclass;
    }

    with(...mixins) {
        return mixins.reduce((c, mixin) => mixin(c), this.superclass);
    }
}

const mix = superclass => new MixinBuilder(superclass);

const initMongo = async (mongoose, uri) => {
    mongoose.set("useNewUrlParser", true);
    mongoose.set("useFindAndModify", false);
    mongoose.set("useCreateIndex", true);
    mongoose.set("useUnifiedTopology", true);
    await mongoose.connect(uri, {
        useNewUrlParser: true,
        useUnifiedTopology: true
    });
};

const destroyMongo = mongoose => {
    mongoose.disconnect();
};

const equal = function(first, second) {
    if (first === second) {
        return true;
    }

    if (typeof_(first) !== typeof_(second)) {
        return false;
    }

    if (isPrimitive(first) && isPrimitive(second)) {
        return first === second;
    }

    if (first instanceof Date && second instanceof Date) {
        return first === second;
    }

    if (Object.keys(first).length !== Object.keys(second).length) {
        return false;
    }

    for (const key in first) {
        if (!(key in second)) return false;
        if (!equal(first[key], second[key])) return false;
    }

    return true;
};

const isPrimitive = function(object) {
    return object !== Object(object);
};

const typeof_ = function(object) {
    if (object === null) return "null";
    if (Array.isArray(object)) return "array";
    return typeof object;
};

const matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;

const escapeStringRegexp = function(string) {
    if (typeof string !== "string") {
        throw new TypeError("Expected a string");
    }

    return string.replace(matchOperatorsRegex, "\\$&");
};

/* The default minimum value meaning that this is the
maximum value that one integer value may have for the
size rounding operation to be performed */
const DEFAULT_MINIMUM = 1024;

/* The default number of places (digits) that are going
to be used for the string representation in the round
based conversion of size units to be performed */
const DEFAULT_PLACES = 3;

/* The size unit coefficient as an integer value, this is
going to be used in each of the size steps as divisor */
const SIZE_UNIT_COEFFICIENT = 1024;

/* The simplified size units list that contains the complete set of
units indexed by the depth they represent */
const SIZE_UNITS_LIST_S = ["B", "K", "M", "G", "T", "P", "E", "Z", "Y"];

/* The size units list that contains the complete set of
units indexed by the depth they represent */
const SIZE_UNITS_LIST = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];

const sizeRoundUnit = function(
    sizeValue,
    minimum = DEFAULT_MINIMUM,
    places = DEFAULT_PLACES,
    reduce = true,
    space = false,
    justify = false,
    simplified = false,
    depth = 0
) {
    // in case the current size value is acceptable (less than
    // the minimum) this is the final iteration and the final
    // string representation is going to be created
    if (sizeValue < minimum) {
        // calculates the maximum size of the string that is going
        // to represent the base size value as the number of places
        // plus one (representing the decimal separator character)
        const sizeS = places + 1;

        // calculates the target number of decimal places taking
        // into account the size (in digits) of the current size
        // value, this may never be a negative number
        const logValue = sizeValue && Math.log10(sizeValue);
        const digits = Math.trunc(logValue) + 1;
        places = places - digits;
        places = places > 0 ? places : 0;

        // rounds the size value, then converts the rounded
        // size value into a string based representation
        let sizeValueS = sizeValue.toFixed(places);

        // forces the reduce flag when the depth is zero, meaning
        // that an integer value will never be decimal, this is
        // required to avoid strange results for depth zero
        reduce = reduce || depth === 0;

        // in case the dot value is not present in the size value
        // string adds it to the end otherwise an issue may occur
        // while removing extra padding characters for reduce
        if (reduce && !sizeValueS.includes(".")) sizeValueS += ".";

        // strips the value from zero appended to the right and
        // then strips the value also from a possible decimal
        // point value that may be included in it, this is only
        // performed in case the reduce flag is enabled
        if (reduce) sizeValueS = sizeValueS.replace(/0+$/, "");
        if (reduce) sizeValueS = sizeValueS.replace(/\.$/, "");

        // in case the justify flag is set runs the justification
        // process on the size value taking into account the maximum
        // size of the associated size string
        if (justify) sizeValueS = _rjust(sizeValueS, sizeS);
        // retrieves the size unit (string mode) for the current
        // depth according to the provided map
        let sizeUnit;
        if (simplified) sizeUnit = SIZE_UNITS_LIST_S[depth];
        else sizeUnit = SIZE_UNITS_LIST[depth];

        // retrieves the appropriate separator based
        // on the value of the space flag
        const separator = (space && " ") || "";

        // creates the size value string appending the rounded
        // size value string and the size unit and returns it
        // to the caller method as the size value string
        const sizeValueString = sizeValueS + separator + sizeUnit;
        return sizeValueString;
    }
    // otherwise the value is not acceptable and a new iteration
    // must be ran with one less depth of size value
    else {
        // re-calculates the new size value, increments the depth
        // and runs the size round unit again with the new values
        const newSizeValue = parseFloat(sizeValue) / SIZE_UNIT_COEFFICIENT;
        const newDepth = depth + 1;
        return sizeRoundUnit(
            newSizeValue,
            minimum,
            places,
            reduce,
            space,
            justify,
            simplified,
            newDepth
        );
    }
};

const _rjust = function(str, length) {
    const lengthToFill = length - str.length;
    return lengthToFill <= 0 ? str : " ".repeat(lengthToFill) + str;
};

const camelToUnderscore = function(value, separator = "_") {
    if (!value) return value;
    return value
        .replace(/\.?([A-Z])/g, (x, y) => separator + y.toLowerCase())
        .replace(RegExp("^" + separator), "");
};

const underscoreToCamel = function(value, lower = false, separator = "_") {
    if (!value) return value;
    const slices = value.split(separator);
    return slices
        .map((s, i) => {
            if (i === 0 && lower) return s.charAt(0).toLowerCase() + s.slice(1);
            return s.charAt(0).toUpperCase() + s.slice(1);
        })
        .join("");
};

/**
 * Encodes the multiple values as and encoded URI component, the
 * values can be wither defined as an array (order is preserved)
 * or as an object (where sequence order is not preserved).
 *
 * The value of each item can be either a primitive type or a sequence
 * in case it's of sequence the values are going to be encoded as
 * multiple parameters separated by the '&' character.
 *
 * @param {(Array|Object[])} values The values to be encoded as an
 * URI component (like GET params).
 * @returns {String} A string with the query encoded values.
 */
const urlEncode = function(values) {
    // constructs the parts array that is going to
    // store the multiple and values
    const parts = [];

    // in case the provided value is not an array
    // then assumes it's an object and retrieve entries
    if (!Array.isArray(values)) {
        values = Object.entries(values);
    }

    // iterates over the complete set of pairs available
    // from the key value pairs to be able to encode them
    // properly, notice that the values themselves can be
    // sequences allowing multiple repetition of key
    values.forEach(([key, value]) => {
        if (!Array.isArray(value)) {
            value = [value];
        }
        const keyEncoded = encodeURIComponent(key);
        value.forEach(_value => {
            if (_value === undefined || _value === null) {
                return;
            }
            const valueEncoded = encodeURIComponent(_value);
            parts.push(`${keyEncoded}=${valueEncoded}`);
        });
    });

    // joins the complete set of parts with the and
    // separator and then returns the final string value
    return parts.join("&");
};

const absoluteUrl = function(path, name = "BASE_URL", fallback = undefined) {
    const baseUrl = conf(name, fallback);
    if (!baseUrl) return null;
    return `${baseUrl}${path}`;
};

class YoniusError extends Error {
    constructor(message, code = 500) {
        super(message);
        this.name = this.constructor.name;
        this.code = code;
    }

    get isClient() {
        return Math.floor(this.code / 100) === 4;
    }

    get isServer() {
        return Math.floor(this.code / 100) === 5;
    }
}

class OperationalError extends YoniusError {
    constructor(message = "Operational error", code = 500) {
        super(message, code);
    }
}

class NotFoundError extends OperationalError {
    constructor(message = "Not found", code = 404) {
        super(message, code);
    }
}

class NotImplementedError extends OperationalError {
    constructor(message = "Not implemented", code = 501) {
        super(message, code);
    }
}

class ValidationError extends OperationalError {
    constructor(message = "Validation of submitted data failed", code = 400) {
        super(message, code);
    }
}

class AttributeError extends YoniusError {
    constructor(message = "Attribute not found") {
        super(message);
    }
}

/**
 * The simple regex used to validate
 * if the provided value is a "simple" one meaning
 * that it may be used safely for URL parts
 */
const SIMPLE_REGEX = /^[\:\.\s\w-]+$/;

/**
 * The email regex used to validate
 * if the provided value is in fact an email
 */
const EMAIL_REGEX = /^[\w\d\._%+-]+@[\w\d\.\-]+$/;

/**
 * The URL regex used to validate
 * if the provided value is in fact an URL/URI
 */
const URL_REGEX = /^\w+\:\/\/([^@]+\:[^@]+@)?[^\:\/\?#]+(\:\d+)?(\/[^\?#]+)*\/?(\?[^#]*)?(#.*)?$/;

const eq = function(valueC, message = "Must be equal to %{1}") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
    };
    return validation;
};

const gt = function(valueC, message = "Must be greater than %{1}") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value > valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
    };
    return validation;
};

const gte = function(valueC, message = "Must be greater than or equal to %{1}") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value >= valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
    };
    return validation;
};

const notEmpty = function(message = "Value is empty") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value.length) return true;
        throw new ValidationError(message);
    };
    return validation;
};

const isIn = function(valueC, message = "Value must be one of: %{1}") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (valueC.includes(value)) return true;
        throw new ValidationError(message.replace("%{1}", valueC.join(", ")));
    };
    return validation;
};

const isUpper = function(message = "Value contains lower cased characters") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value === value.toUpperCase()) return true;
        throw new ValidationError(message);
    };
    return validation;
};

const isLower = function(message = "Value contains upper cased characters") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value === value.toLowerCase()) return true;
        throw new ValidationError(message);
    };
    return validation;
};

const isSimple = function(message = "Value contains invalid characters") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value.match(SIMPLE_REGEX)) return true;
        throw new ValidationError(message);
    };
    return validation;
};

const isEmail = function(message = "Value is not a valid email") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value.match(EMAIL_REGEX)) return true;
        throw new ValidationError(message);
    };
    return validation;
};

const isUrl = function(message = "Value is not a valid URL") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value.match(URL_REGEX)) return true;
        throw new ValidationError(message);
    };
    return validation;
};

const isRegex = function(regex, message = "Value has incorrect format") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value === "") return true;
        if (value.match(new RegExp(regex))) return true;
        throw new ValidationError(message);
    };
    return validation;
};

const stringGt = function(valueC, message = "Must be larger than %{1} characters") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value.length > valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
    };
    return validation;
};

const stringLt = function(valueC, message = "Must be smaller than %{1} characters") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value.length < valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
    };
    return validation;
};

const stringEq = function(valueC, message = "Must be exactly %{1} characters") {
    const validation = (value, ctx) => {
        if (value === undefined) return true;
        if (value === null) return true;
        if (value.length === valueC) return true;
        throw new ValidationError(message.replace("%{1}", String(valueC)));
    };
    return validation;
};

const all = function(validation) {
    const _validation = (sequence, ctx) => {
        if (sequence === undefined) return true;
        if (sequence === null) return true;
        for (const value of sequence) {
            validation(value, ctx);
        }
        return true;
    };
    return _validation;
};

const AUTH_ERRORS = [401, 403, 440, 499];

class API extends Observable {
    constructor(kwargs = {}) {
        super();
        this.kwargs = kwargs;
    }

    async build(method, url, options = {}) {}

    async authCallback(params, headers) {}

    async get(url, options = {}) {
        const result = await this.methodBasic("GET", url, options);
        return result;
    }

    async post(url, options = {}) {
        const result = await this.methodPayload("POST", url, options);
        return result;
    }

    async put(url, options = {}) {
        const result = await this.methodPayload("PUT", url, options);
        return result;
    }

    async delete(url, options = {}) {
        const result = await this.methodBasic("DELETE", url, options);
        return result;
    }

    async patch(url, options = {}) {
        const result = await this.methodPayload("PATCH", url, options);
        return result;
    }

    async options(url, options = {}) {
        const result = await this.methodBasic("OPTIONS", url, options);
        return result;
    }

    async methodBasic(method, url, options = {}) {
        options.params = options.params !== undefined ? options.params : {};
        options.headers = options.headers !== undefined ? options.headers : {};
        try {
            return await this._methodBasic(method, url, options);
        } catch (err) {
            if (AUTH_ERRORS.includes(err.code)) {
                await this.authCallback(options.params, options.headers);
                return await this._methodBasic(method, url, options);
            } else {
                throw err;
            }
        }
    }

    async methodPayload(method, url, options = {}) {
        options.params = options.params !== undefined ? options.params : {};
        options.headers = options.headers !== undefined ? options.headers : {};
        try {
            return await this._methodPayload(method, url, options);
        } catch (err) {
            if (AUTH_ERRORS.includes(err.code)) {
                await this.authCallback(options.params, options.headers);
                return await this._methodPayload(method, url, options);
            } else {
                throw err;
            }
        }
    }

    async _methodBasic(method, url, options = {}) {
        const params = options.params !== undefined ? options.params : {};
        const headers = options.headers !== undefined ? options.headers : {};
        const kwargs = options.kwargs !== undefined ? options.kwargs : {};
        const handle = options.handle !== undefined ? options.handle : true;
        const getAgent = options.getAgent !== undefined ? options.getAgent : undefined;
        await this.build(method, url, {
            params: params,
            headers: headers,
            kwargs: kwargs
        });
        const query = urlEncode(params || {});
        if (query) url += url.includes("?") ? "&" + query : "?" + query;
        const response = await fetch(url, {
            method: method,
            headers: headers || {},
            agent: getAgent || globals.getAgent || undefined
        });
        const result = handle ? await this._handleResponse(response) : response;
        return result;
    }

    async _methodPayload(method, url, options = {}) {
        const params = options.params !== undefined ? options.params : {};
        let headers = options.headers !== undefined ? options.headers : {};
        let data = options.data !== undefined ? options.data : null;
        const dataJ = options.dataJ !== undefined ? options.dataJ : null;
        const dataM = options.dataM !== undefined ? options.dataM : null;
        let mime = options.mime !== undefined ? options.mime : null;
        const kwargs = options.kwargs !== undefined ? options.kwargs : {};
        const handle = options.handle !== undefined ? options.handle : true;
        const getAgent = options.getAgent !== undefined ? options.getAgent : undefined;

        await this.build(method, url, {
            params: params,
            headers: headers,
            data: data,
            dataJ: dataJ,
            dataM: dataM,
            mime: mime,
            kwargs: kwargs
        });

        const query = urlEncode(params || {});

        if (data !== null) {
            if (query) url += url.includes("?") ? "&" + query : "?" + query;
        } else if (dataJ !== null) {
            data = JSON.stringify(dataJ);
            if (query) url += url.includes("?") ? "&" + query : "?" + query;
            mime = mime || "application/json";
        } else if (dataM !== null) {
            if (query) url += url.includes("?") ? "&" + query : "?" + query;
            [mime, data] = this._encodeMultipart(dataM, mime, true);
        } else if (query) {
            data = query;
            mime = mime || "application/x-www-form-urlencoded";
        }

        headers = Object.assign({}, headers);
        if (mime) headers["Content-Type"] = mime;

        const response = await fetch(url, {
            method: method,
            headers: headers || {},
            body: data,
            agent: getAgent || global.getAgent || undefined
        });
        const result = handle ? await this._handleResponse(response) : response;
        return result;
    }

    async _handleResponse(response, errorMessage = "Problem in request") {
        let result = null;
        if (
            response.headers.get("content-type") &&
            response.headers.get("content-type").toLowerCase().startsWith("application/json")
        ) {
            result = await response.json();
        } else if (
            response.headers.get("content-type") &&
            response.headers.get("content-type").toLowerCase().startsWith("text/")
        ) {
            result = await response.text();
        } else {
            result = await response.blob();
        }
        verify(response.ok, result.error || errorMessage, response.status || 500);
        return result;
    }

    _encodeMultipart(fields, mime = null, doseq = false) {
        mime = mime || "multipart/form-data";

        const boundary = this._createBoundary(fields, undefined, doseq);

        const encoder = new TextEncoder("utf-8");

        const buffer = [];

        for (let [key, values] of Object.entries(fields)) {
            const isList = doseq && Array.isArray(values);
            values = isList ? values : [values];

            for (let value of values) {
                if (value === null) continue;

                let header;

                if (
                    typeof value === "object" &&
                    !(value instanceof Array) &&
                    value.constructor !== Uint8Array
                ) {
                    const headerL = [];
                    let data = null;
                    for (const [key, item] of Object.entries(value)) {
                        if (key === "data") data = item;
                        else headerL.push(`${key}: ${item}`);
                    }
                    value = data;
                    header = headerL.join("\r\n");
                } else if (value instanceof Array) {
                    let name = null;
                    let contents = null;
                    let contentTypeD = null;
                    if (value.length === 2) [name, contents] = value;
                    else [name, contentTypeD, contents] = value;
                    header = `Content-Disposition: form-data; name="${key}"; filename="${name}"`;
                    if (contentTypeD) header += `\r\nContent-Type: ${contentTypeD}`;
                    value = contents;
                } else {
                    header = `Content-Disposition: form-data; name="${key}"`;
                    value = value.constructor === Uint8Array ? value : encoder.encode(value);
                }

                buffer.push(encoder.encode("--" + boundary + "\r\n"));
                buffer.push(encoder.encode(header + "\r\n"));
                buffer.push(encoder.encode("\r\n"));
                buffer.push(value);
                buffer.push(encoder.encode("\r\n"));
            }
        }

        buffer.push(encoder.encode("--" + boundary + "--\r\n"));
        buffer.push(encoder.encode("\r\n"));
        const body = this._joinBuffer(buffer);
        const contentType = `${mime}; boundary=${boundary}`;

        return [contentType, body];
    }

    _createBoundary(fields, size = 32, doseq = false) {
        return "Vq2xNWWHbmWYF644q9bC5T2ALtj5CynryArNQRXGYsfm37vwFKMNsqPBrpPeprFs";
    }

    _joinBuffer(bufferArray) {
        const bufferSize = bufferArray.map(item => item.byteLength).reduce((a, v) => a + v, 0);
        const buffer = new Uint8Array(bufferSize);
        let offset = 0;
        for (const item of bufferArray) {
            buffer.set(item, offset);
            offset += item.byteLength;
        }
        return buffer;
    }
}

const buildGetAgent = (AgentHttp, AgentHttps, set = true, options = {}) => {
    const httpAgent = new AgentHttp({
        keepAlive: options.keepAlive === undefined ? true : options.keepAlive,
        keepAliveMsecs: options.keepAliveMsecs || 120000,
        timeout: options.timeout || 60000,
        scheduling: options.scheduling || "fifo"
    });
    const httpsAgent = new AgentHttps({
        keepAlive: options.keepAlive === undefined ? true : options.keepAlive,
        keepAliveMsecs: options.keepAliveMsecs || 120000,
        timeout: options.timeout || 60000,
        scheduling: options.scheduling || "fifo"
    });
    const getAgent = parsedURL => (parsedURL.protocol === "http:" ? httpAgent : httpsAgent);
    if (set) globals.getAgent = getAgent;
    return getAgent;
};

/**
 * Tries to patch the global environment with a proper `getAgent`
 * function that can handle HTTP and HTTP connection polling.
 *
 * This can only be performed in a node.js environment (uses `require`).
 *
 * @returns {Function} The `getAgent` function that has just been
 * built and set in the globals.
 */
const patchAgent = () => {
    if (typeof require !== "function") return;
    if (globals.getAgent) return;
    let http, https;
    try {
        http = require("http");
        https = require("https");
    } catch (err) {
        return;
    }
    if (!http || !https) return;
    if (!http.Agent || !https.Agent) return;
    return buildGetAgent(http.Agent, https.Agent, true);
};

// patches the global agent if possible, using the
// global dynamic require statements
patchAgent();

class OAuthAPI extends API {}

class OAuth1API extends OAuthAPI {}

class OAuth2API extends OAuthAPI {
    constructor(kwargs = {}) {
        super(kwargs);
        this.accessToken = null;
    }

    async build(method, url, options = {}) {
        await super.build(method, url, options);
        const params = options.params !== undefined ? options.params : {};
        const headers = options.headers !== undefined ? options.headers : {};
        const kwargs = options.kwargs !== undefined ? options.kwargs : {};
        const token = kwargs.token === undefined ? this.tokenDefault : kwargs.token;
        delete kwargs.token;
        if (token && this.oauthTypes.includes("param")) {
            params[this.oauthParam] = this.getAccessToken();
        }
        if (token && this.oauthTypes.includes("header")) {
            headers.Authorization = `Bearer ${this.getAccessToken()}`;
        }
    }

    getAccessToken() {
        if (this.accessToken) return this.accessToken;
        throw new Error("No access token found must re-authorize");
    }

    get oauthTypes() {
        return ["param", "header"];
    }

    get oauthParam() {
        return "access_token";
    }

    get tokenDefault() {
        return true;
    }
}

/**
 * Ensures that the current "session" context contains the
 * requested ACL token as valid.
 *
 * In case the validation fails an exception is raised
 * indicating the auth validation error.
 *
 * @param {String} token The ACL token to ensure permission,
 * the logged user should be allowed to id.
 * @param {Object} ctx The context object to be used in
 * the session basic ACL retrieval, should contain proper
 * injected methods for retrieval (eg: `getAcl`).
 */
const ensurePermissions = async (token, ctx) => {
    // retrieves the ACL values from the current context and
    // then uses the ACL to obtain the valid expanded tokens map
    const acl = ctx.getAcl ? await ctx.getAcl(ctx) : {};
    const tokens = toTokensM(acl);

    // in case the permission validation test is not positive
    // then an exception should be raised indicating the issue
    if (!hasPermission(token, tokens)) {
        throw new OperationalError("You don't have authorization to access this resource", 401);
    }
};

/**
 * Converts the provided list of token strings separated by dots
 * into a map based representation on an hierarchical structure.
 *
 * @param {Array} tokens A linear array of tokens to convert into
 * an hierarchical representation.
 * @returns {Object} The map containing the hierarchy of tokens
 * for the provided linear string based sequence of tokens.
 */
const toTokensM = tokens => {
    const tokensM = {};

    if (tokens === undefined) return tokensM;
    if (tokens === null) return tokensM;
    if (!Array.isArray(tokens)) return tokensM;

    for (const token of tokens) {
        let tokensC = tokensM;
        const tokenL = token.split(".");
        const head = tokenL.slice(0, tokenL.length - 1);
        const tail = tokenL[tokenL.length - 1];

        for (const tokenP of head) {
            let current = tokensC[tokenP] || {};
            const isDict = typeof current === "object";
            if (!isDict) current = { _: current };
            tokensC[tokenP] = current;
            tokensC = current;
        }

        const leaf = tokensC[tail] || null;
        if (leaf && typeof leaf === "object") leaf._ = true;
        else tokensC[tail] = true;
    }

    return tokensM;
};

const hasPermission = (token, tokensM = null) => {
    if (!token) return true;
    if (tokensM === undefined || tokensM === null) return false;

    const tokenL = token.split(".");
    for (const tokenP of tokenL) {
        if (typeof tokensM !== "object") return false;
        if (tokensM["*"]) return true;
        if (tokensM[tokenP] === undefined) return false;
        tokensM = tokensM[tokenP];
    }

    const isDict = typeof tokensM === "object";
    const result = isDict ? tokensM._ || false : tokensM;

    return Boolean(result);
};

const REGISTRY = {};

const load = async function() {
    await load$1();
};

const unload = async function() {};

const register = function(name, value) {
    REGISTRY[name] = value;
};

const unregister = function(name) {
    delete REGISTRY[name];
};

const request = function(name) {
    if (REGISTRY[name] === undefined) {
        throw new OperationalError(`Name '${name}' not found in registry`);
    }
    return REGISTRY[name];
};

class FileTuple extends Array {
    static fromData(data, name = null, mime = null) {
        const fileTuple = new this(name, mime, data);
        return fileTuple;
    }

    static fromString(dataString, name = null, mime = null, { encoding = "utf-8" } = {}) {
        const data = new TextEncoder(encoding).encode(dataString);
        return this.fromData(data, name, mime);
    }

    static fromArrayBuffer(arrayBuffer, name = null, mime = null) {
        const buffer = Buffer.from(arrayBuffer);
        return this.fromData(buffer, name, mime);
    }

    static async fromBlob(blob, name = null, mime = null) {
        const arrayBuffer = await blob.arrayBuffer();
        return this.fromArrayBuffer(arrayBuffer, name, mime);
    }

    get name() {
        return this[0];
    }

    get mime() {
        return this[1];
    }

    get data() {
        return this[2];
    }
}

class AbstractType {
    async jsonV() {
        return JSON.stringify(this);
    }

    async mapV() {
        const result = await this.jsonV();
        return result;
    }
}

class Reference extends AbstractType {}

const reference = function(target, { name = null, dumpall = false } = {}) {
    name = name || "id";
    const targetT = target.constructor.name;
    const isReference = targetT === "string";
    const reserved = ["id", "_target", "_object", "_type", "__dict__"];

    class _Reference extends Reference {
        constructor(id) {
            super(id);

            this.__start__();

            const proxy = new Proxy(this, {
                get(target, name) {
                    // special case to avoid this Proxy
                    // breaking when being accessed in
                    // an async context
                    if (name === "then") return target.then;

                    if (name in target) return target[name];

                    const exists = Boolean(target._object && target._object[name]);
                    if (exists) return target._object[name];
                    if (target.isResolved) throw new AttributeError(`'${name}' not found`);
                    return target.get(name);
                },
                set(target, name, value) {
                    if (name in target) {
                        target[name] = value;
                        return true;
                    }

                    // verifies if the reference object exists in the current
                    // reference instance, that's the case if the object name is
                    // defined in the dictionary and the referenced object contains
                    // an attribute with the name referred, for those situations
                    // defers the setting of the attribute to the reference object
                    const exists =
                        target._object !== undefined && target._object[name] !== undefined;
                    if (exists) {
                        target._object[name] = value;
                        return true;
                    }

                    // otherwise this is a normal attribute setting and the current
                    // object's dictionary must be changed so that the new value is set
                    target[name] = value;
                    return true;
                }
            });

            if (id instanceof _Reference) return this.buildI(id);
            else if (id instanceof this.constructor._target) return this.buildO(id);
            else this.build(id);

            return proxy;
        }

        static get schema() {
            return target.schema;
        }

        static get schemaSafe() {
            return target.schemaSafe;
        }

        static get collection() {
            return target.collection;
        }

        static get idName() {
            return "id";
        }

        static get increments() {
            return target.increments;
        }

        static get dataOptions() {
            return target.dataOptions;
        }

        static _collection(options) {
            return target._collection(options);
        }

        static async _increment(name) {
            return target._increment(name);
        }

        static async _ensureMin(name, value) {
            return target._ensureMin(name, value);
        }

        static _eagerB(eager) {
            return target._eagerB(eager);
        }

        async get(name) {
            await this.resolve();
            const value = this._object[name];
            if (value === undefined) throw new AttributeError(`'${name}' not found`);
            return value;
        }

        async set(name, value) {
            // in case the name that is being set is not part of the reserved
            // names for the reference underlying structure the object resolution
            // is triggered to make sure the underlying object exists and is loaded
            if (!reserved.includes(name)) {
                await target.resolve();
            }

            // verifies if the reference object exists in the current
            // reference instance, that's the case if the object name is
            // defined in the dictionary and the referenced object contains
            // an attribute with the name referred, for those situations
            // defers the setting of the attribute to the reference object
            const exists = this._object !== undefined && this._object[name] !== undefined;
            if (exists) {
                this._object[name] = value;
                return true;
            }

            // otherwise this is a normal attribute setting and the current
            // object's dictionary must be changed so that the new value is set
            this[name] = value;
        }

        __start__() {
            if (isReference) this._target = this.constructor._target;
            else this._target = target;
            verify(this._target);
            const meta = this._target.schema[name];
            this._type = meta.type || String;
        }

        /**
         * The name of the key (join) attribute for the
         * reference that is going to be created, this
         * name may latter be used to cast the value
         */
        static get _name() {
            return name;
        }

        static get _default() {
            return new this(null);
        }

        static get _target() {
            if (isReference) {
                throw new NotImplementedError("References only work with classes, not class names");
            }
            return target;
        }

        static _btype() {
            let _target;
            if (isReference) _target = this._target();
            else _target = target;
            const meta = _target.schema[name];
            return meta.type || String;
        }

        build(id, cast = true) {
            const isUnset = ["", null, undefined].includes(id);
            cast = cast && !isUnset;
            if (cast) id = this.constructor._target.cast(name, id);
            this.id = id;
            this._object = null;
        }

        buildI(reference) {
            this.id = reference.id;
            this._object = reference._object;
        }

        buildO(object) {
            this.id = object[this.constructor._name];
            this._object = object;
        }

        async refV() {
            return this.val;
        }

        async jsonV() {
            if (dumpall) {
                const result = await this.resolve();
                return result;
            }
            return this.val;
        }

        async mapV() {
            throw new NotImplementedError();
        }

        get val() {
            const isEmpty = ["", null, undefined].includes(this.id);
            if (isEmpty) return null;
            return this._type(this.id);
        }

        async resolve(kwargs = {}) {
            // verifies if the underlying object reference exists
            // in the current names dictionary and if it exists
            // verifies if it's valid (value is valid) if that's
            // the case returns the current value immediately
            const exists = this._object !== undefined;
            if (exists && this._object) return this._object;

            // verifies if there's an id value currently set in
            // the reference in case it does not exists sets the
            // object value in the current instance with a none
            // value and then returns this (invalid value)
            if (!this.id) {
                const _object = null;
                this._object = _object;
                return _object;
            }

            // creates the map of keyword based arguments that are going
            // to be used in the resolution of the reference and uses the
            // data source based get attribute to retrieve the object
            // that represents the reference
            kwargs[name] = this.constructor._target.cast(name, this.id);
            kwargs.raiseE = kwargs.raiseE || false;
            kwargs.eagerL = kwargs.eagerL || false;
            kwargs.resolveA = kwargs.resolveA || false;
            const _object = await this.constructor._target.get(kwargs);

            // sets the resolved object (using the current id attribute)
            // in the current instance's dictionary and then returns this
            // value to the caller method as the resolved value
            this._object = _object;
            return _object;
        }

        get isResolved() {
            const exists = this._object !== undefined;
            return Boolean(exists && this._object);
        }

        async isResolvable() {
            await this.resolve();
            return this._object !== null;
        }
    }

    return _Reference;
};

class References extends AbstractType {}

const references = function(target, { name = undefined, dumpall = false } = {}) {
    name = name || "id";
    const targetT = target.constructor.name;
    const isReference = targetT === "string";
    const ReferenceC = reference(target, { name: name, dumpall: dumpall });

    class _References extends References {
        constructor(ids) {
            super(ids);

            this.__start__();

            const proxy = new Proxy(this, {
                get(target, name) {
                    if (name in target) return target[name];
                    return target.objects[name];
                }
            });

            if (ids instanceof _References) return this.buildI(ids);
            else this.build(ids);

            return proxy;
        }

        __start__() {
            if (isReference) this._target = this.constructor._target;
            else this._target = target;
            verify(this._target);
        }

        /**
         * The name of the key (join) attribute for the
         * reference that is going to be created, this
         * name may latter be used to cast the value
         */
        static get _name() {
            return name;
        }

        static get _default() {
            return new this([]);
        }

        static get _target() {
            return ReferenceC._target;
        }

        static _btype() {
            return ReferenceC._btype;
        }

        get items() {
            return this.objects;
        }

        build(ids) {
            const isValid = ![null, undefined].includes(ids);
            if (isValid && !Array.isArray(ids)) ids = [ids];

            this.ids = ids;
            this.objects = [];
            this.objectsM = {};

            this.setIds(this.ids);
        }

        buildI(references) {
            this.ids = references.ids;
            this.objects = references.objects;
            this.objectsM = references.objectsM;
        }

        setIds(ids = []) {
            this.ids = [];
            ids.forEach(id => {
                if (["", null, undefined].includes(id)) return;
                const object = new ReferenceC(id);
                const objectId = object.id;
                this.ids.push(objectId);
                this.objects.push(object);
                this.objectsM[objectId] = object;
            });
        }

        async refV() {
            const result = await Promise.all(this.objects.map(async object => await object.refV()));
            return result;
        }

        async jsonV() {
            const result = await Promise.all(
                this.objects.map(async object => await object.jsonV())
            );
            return result;
        }

        async mapV() {
            const result = await Promise.all(this.objects.map(async object => await object.mapV()));
            return result;
        }

        get val() {
            return this.objects.map(object => object.val);
        }

        get list() {
            return this.objects.map(object => object.val);
        }

        async resolve(kwargs = {}) {
            const result = await Promise.all(this.objects.map(object => object.resolve(kwargs)));
            return result;
        }

        find(kwargs = {}) {
            kwargs[name] = {
                $in: this.ids.map(id => this._target.cast(name, id))
            };
            return this._target.find(kwargs);
        }

        paginate(kwargs = {}) {
            kwargs[name] = {
                $in: this.ids.map(id => this._target.cast(name, id))
            };
            return this._target.paginate(kwargs);
        }

        get isEmpty() {
            const idsL = self.ids.length;
            return idsL === 0;
        }

        get isResolved() {
            if (this.objects.length === 0) return true;
            return this.objects[0].isResolved;
        }
    }

    return _References;
};

/**
 * A mapping from yonius types to the schema types to
 * be used by the underlying Mongo collection.
 */
const MONGO_TYPES = [
    [Reference, Object],
    [References, Array]
];

/**
 * Abstract class definition that defines the interface
 * expected to be implemented by data driven collections
 * in the Yonius context.
 */
class Collection {
    constructor(options) {
        this.options = options;
    }

    async find(conditions, projection = {}, options = {}) {
        throw new NotImplementedError();
    }

    async findOne(conditions, projection = {}, options = {}) {
        throw new NotImplementedError();
    }

    async findOneAndUpdate(conditions, data, options = {}) {
        throw new NotImplementedError();
    }

    async findOneAndDelete(conditions, options = {}) {
        throw new NotImplementedError();
    }

    async create(data, options = {}) {
        throw new NotImplementedError();
    }

    async count(conditions, options = {}) {
        throw new NotImplementedError();
    }
}

/**
 * Mongo based collection that implements the collection
 * abstract interface applying it to a specific mongodb
 * instance. Most of the interface is already "mongodb
 * oriented", so only a thin layer of adaptation is required.
 */
class MongoCollection extends Collection {
    constructor(name, schema) {
        super(name, schema);
        this._mongoose = this.constructor.getModel(this.options.name, this.options.schema);
    }

    static getModel(name, schema) {
        // verifies if the model is already present in the global
        // cache and if that the case re-uses it
        this._models = this._models || {};
        if (this._models[name]) return this._models[name];

        // obtains a reference to the mongoose, that
        // should have been registered by 3rd party
        const mongoose = request("mongoose");

        // creates the internal "mongoose" reference to the
        // model by encapsulating its name and schema
        const filteredSchema = { ...schema };
        Object.entries(filteredSchema).forEach(([name, value]) => {
            const found = MONGO_TYPES.find(
                ([type, mongoType]) => value.type.prototype instanceof type
            );
            if (!found) return;
            filteredSchema[name].type = found[1];
        });
        this._models[name] = mongoose.model(name, new mongoose.Schema(filteredSchema));

        // returns the newly constructor mongoose model to
        // the caller methods
        return this._models[name];
    }

    async find(conditions, projection = {}, options = {}) {
        const model = await this._mongoose.find(conditions, projection, options);
        return model;
    }

    async findOne(conditions, projection = {}, options = {}) {
        const model = this._mongoose.findOne(conditions, projection, options);
        return model;
    }

    async findOneAndUpdate(conditions, data, options = {}) {
        const model = await this._mongoose.findOneAndUpdate(conditions, data, {
            upsert: true,
            new: true,
            ...options
        });
        return model;
    }

    async findOneAndDelete(conditions, options = {}) {
        const model = await this._mongoose.findOneAndDelete(conditions, options);
        return model;
    }

    async create(data, options = {}) {
        const models = await this._mongoose.create([data], options);
        return models[0];
    }

    async count(conditions, options = {}) {
        const count = await this._mongoose.countDocuments(conditions);
        return count;
    }
}

var collection = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Collection: Collection,
    MongoCollection: MongoCollection,
    'default': Collection
});

const MEMORY_STORAGE = {};

/**
 * Simple lambda function that removes any
 * empty element from the provided list values
 */
const RE = v => v.filter(i => i !== "");

/**
 * The map associating the various types with the
 * custom builder functions to be used when applying
 * the types function, this is relevant for the built-in
 * types that are meant to avoid using the default constructor
 */
const BUILDERS = {
    [Number]: v => v,
    [String]: v => v,
    [Array]: v => (Array.isArray(v) ? RE(v) : typeof v === "string" ? JSON.parse(v) : RE([v])),
    [Boolean]: v => (typeof v === "boolean" ? v : !["", "0", "false", "False"].includes(v)),
    [Object]: v => (typeof v === "string" ? JSON.parse(v) : v)
};

/**
 * The default values to be set when a type
 * conversion fails for the provided string value
 * the resulting value may be returned when a validation
 * fails an so it must be used carefully
 */
const TYPE_DEFAULTS = {
    bytes: null,
    unicode: null,
    int: null,
    float: null,
    bool: false,
    list: () => [],
    dict: () => ({}),
    object: () => ({})
};

/**
 * The various data types that are considered to be references
 * so that they are lazy loaded from the data source, these kind
 * of types should be compliant to a common interface so that they
 * may be used "blindly" from an external entity
 */
const TYPE_REFERENCES = [Reference, References];

/**
 * The map that associates the various operators with the boolean
 * values that define if an insensitive base search should be used
 * instead of the "typical" sensitive search.
 */
const INSENSITIVE = {
    likei: true,
    llikei: true,
    rlikei: true
};

/**
 * The map containing the mapping association between the
 * normalized version of the operators and the infra-structure
 * specific value for each of this operations, note that some
 * of the values don't have a valid mapping for this operations
 * the operator must be ignored and not used explicitly.
 */
const OPERATORS = {
    eq: null,
    equals: null,
    ne: "$ne",
    not_equals: "$ne",
    in: "$in",
    nin: "$nin",
    not_in: "$nin",
    like: "$regex",
    likei: "$regex",
    llike: "$regex",
    llikei: "$regex",
    rlike: "$regex",
    rlikei: "$regex",
    gt: "$gt",
    greater: "$gt",
    gte: "$gte",
    greater_equal: "$gte",
    lt: "$lt",
    lesser: "$lt",
    lte: "$lte",
    lesser_equal: "$lte",
    null: null,
    is_null: null,
    not_null: "$ne",
    is_not_null: "$ne",
    contains: "$all"
};

/**
 * Map that associates each of the normalized operations with
 * an inline function that together with the data type maps the
 * the base string based value into the target normalized value.
 */
const VALUE_METHODS = {
    in: (v, t) => v.split(";").map(t),
    not_in: (v, t) => v.split(";").map(t),
    like: (v, t) => "^.*" + escapeStringRegexp(v) + ".*$",
    likei: (v, t) => "^.*" + escapeStringRegexp(v) + ".*$",
    llike: (v, t) => "^.*" + escapeStringRegexp(v) + "$",
    llikei: (v, t) => "^.*" + escapeStringRegexp(v) + "$",
    rlike: (v, t) => "^" + escapeStringRegexp(v) + ".*$",
    rlikei: (v, t) => "^" + escapeStringRegexp(v) + ".*$",
    null: (v, t) => null,
    is_null: (v, t) => null,
    not_null: (v, t) => null,
    is_not_null: (v, t) => null,
    contains: (v, t) => v.split(";").map(t)
};

class Model {
    constructor(options = {}) {
        const fill = options.fill === undefined ? true : options.fill;
        if (fill) this.constructor.fill(this);
    }

    static niw() {
        return new this();
    }

    /**
     * Fills the current model with the proper values so that
     * no values are unset as this would violate the model definition
     * integrity. This is required when retrieving an object(s) from
     * the data source (as some of them may be incomplete).
     *
     * @param {Object} model The model that is going to have its unset
     * attributes filled with "default" data, in case none is provided
     * all of the attributes will be filled with "default" data.
     * @param {Boolean} safe If the safe mode should be used for the fill
     * operation meaning that under some conditions no unit fill
     * operation is going to be applied (eg: retrieval operations).
     */
    static async fill(model = {}, safe = false) {
        for (const [name, field] of Object.entries(this.schema)) {
            if (model[name] !== undefined) continue;
            if (["_id"].includes(model[name])) continue;
            const _private = field.private === undefined ? false : field.private;
            const increment = field.increment === undefined ? false : field.increment;
            if (_private && safe) continue;
            if (increment) continue;
            if (field.initial !== undefined) {
                const initial = field.initial;
                model[name] = initial;
            } else {
                const type = field.type || null;
                let _default = typeD(type, null);
                _default = type._default === undefined ? _default : type._default();
                model[name] = _default;
            }
        }
    }

    static cast(name, value, safe = true) {
        if (!this.schema[name]) return value;
        if (value === null || value === undefined) return value;
        const _definition = this.definitionN(name);
        const _type = _definition.type || String;
        const builder = BUILDERS[_type] || (v => new _type(v));
        try {
            return builder ? builder(value) : value;
        } catch (err) {
            if (!safe) throw err;
            let _default = this.typeD[_type] || null;
            _default = _type._default ? _type._default() : _default;
            return _default;
        }
    }

    static get eagers() {
        return Object.entries(this.schema)
            .filter(([name, field]) => field.eager)
            .map(([name, field]) => name);
    }

    /**
     * The name of the data source adapter that is going
     * to be used to handle this model instance.
     *
     * @type {String}
     */
    static get adapter() {
        return process.env.ADAPTER || "mongo";
    }

    async validate() {
        const errors = [...this._validate()];
        if (errors.length) {
            throw new ValidationError(
                `Invalid model: ${errors.map(err => String(err)).join(", ")}`
            );
        }
    }

    async apply(model) {
        await this.wrap(model);
        return this;
    }

    async wrap(model) {
        await this._wrap(model);
        return this;
    }

    get isNew() {
        return this._id === undefined;
    }

    get model() {
        return this;
    }

    async jsonV() {
        return this.model;
    }

    get string() {
        return JSON.stringify(this.model);
    }

    /**
     * Wraps the provided model object around the current instance, making
     * sure that all of the elements are compliant with the schema.
     *
     * It should be possible to override the `_wrap` operation to implement
     * a custom "way" of setting data into a model.
     *
     * @param {Object} model The model structure that is going to be used
     * to wrap the current model object, meaning that all of its elements
     * are going to be stored in the current object.
     */
    async _wrap(model) {
        for (const key of Object.keys(this.constructor.schema)) {
            const value = model[key];
            if (value === undefined) continue;
            this[key] = this.constructor.cast(key, value);
        }
        if (model._id !== undefined) this._id = model._id;
    }

    * _validate() {
        for (const [name, value] of Object.entries(this.constructor.schema)) {
            const validation = value.validation || false;
            if (!validation) continue;
            for (const callable of validation) {
                try {
                    callable(this[name]);
                } catch (err) {
                    yield err;
                }
            }
        }
    }
}

class ModelStore extends Model {
    static _getAttrs(params, attrs) {
        const _attrs = [];

        attrs.forEach(([attr, value]) => {
            if (params[attr] === undefined) {
                _attrs.push(value);
                return;
            }

            const _value = params[attr];
            delete params[attr];
            _attrs.push(_value);
        });

        return _attrs;
    }

    static async get(params = {}) {
        /* eslint-disable no-unused-vars */
        let [
            fields,
            eager,
            eagerL,
            map,
            rules,
            meta,
            build,
            fill,
            resolveA,
            skip,
            limit,
            sort,
            raiseE
        ] = this._getAttrs(params, [
            ["fields", null],
            ["eager", null],
            ["eagerL", null],
            ["map", false],
            ["rules", true],
            ["meta", false],
            ["build", true],
            ["fill", true],
            ["resolveA", null],
            ["skip", 0],
            ["limit", 0],
            ["sort", null],
            ["raiseE", true]
        ]);
        /* eslint-enable no-unused-vars */
        if (eagerL === null) eagerL = map;
        if (eagerL) eager = this._eagerB(eager);

        const sortObject = {};
        if (sort) {
            sort.forEach(([key, value]) => (sortObject[key] = value));
        }

        const found = await this.collection.findOne(params, this.fields, {
            skip: skip,
            limit: limit,
            sort: sortObject
        });

        if (!found && raiseE) {
            let message;
            if (_isDevel()) {
                message = `${this.name} not found for ${JSON.stringify(params)}`;
            } else {
                message = `${this.name} not found`;
            }
            throw new NotFoundError(message);
        }
        let model = found ? await new this().wrap(found) : found;
        if (model) {
            if (eager) model = await this._eager(model, eager, { map: map });
        }
        return model;
    }

    static async find(params = {}) {
        /* eslint-disable no-unused-vars */
        const [
            fields,
            eager,
            eagerL,
            map,
            rules,
            meta,
            build,
            fill,
            resolveA,
            skip,
            limit,
            sort,
            raiseE
        ] = this._getAttrs(params, [
            ["fields", null],
            ["eager", null],
            ["eagerL", null],
            ["map", false],
            ["rules", true],
            ["meta", false],
            ["build", true],
            ["fill", true],
            ["resolveA", null],
            ["skip", 0],
            ["limit", 0],
            ["sort", null],
            ["raiseE", false]
        ]);
        /* eslint-enable no-unused-vars */

        this._findS(params);
        this._findD(params);

        const sortObject = {};
        if (sort) {
            sort.forEach(([key, value]) => (sortObject[key] = value));
        }

        const found = await this.collection.find(params, this.fields, {
            skip: skip,
            limit: limit,
            sort: sortObject
        });

        if (found.length === 0 && raiseE) {
            let message;
            if (_isDevel()) {
                message = `${this.name} not found for ${JSON.stringify(params)}`;
            } else {
                message = `${this.name} not found`;
            }
            throw new NotFoundError(message);
        }

        const models = await Promise.all(found.map(v => new this().wrap(v)));
        return models;
    }

    static async count(params = {}) {
        let result = null;
        if (Object.keys(params).length > 0) {
            result = await this.collection.find(params);
            result = result.length;
        } else {
            result = await this.collection.count();
        }
        return result;
    }

    static _findD(params) {
        // retrieves the find definition into a local variable, then
        // removes the find definition from the named arguments map
        // so that it's not going to be erroneously used by the
        // underlying find infra-structure
        const findD = params.find_d;
        delete params.find_d;

        // in case the find definition is currently not defined in the
        // named arguments map returns immediately as nothing is
        // meant to be done on this method
        if (!findD) return;

        // tries to retrieve the value of the operator that is going
        // to be used to "join" the multiple find parts (find values)
        const findO = params.find_o;
        delete params.find_o;

        // verifies that the data type for the find definition is a
        // valid sequence and in case its not converts it into one
        // so that it may be used in sequence valid logic
        const _findD = Array.isArray(findD) ? findD : [findD];

        // iterates over all the filters defined in the filter definition
        // so that they may be used to update the provided arguments with
        // the filter defined in each of their lines
        for (const filter of _findD) {
            // in case the filter is not valid (unset or invalid) it's going
            // to be ignored as no valid information is present
            if (!filter) continue;

            // splits the filter string into its three main components
            // the name, operator and value, that are going to be processed
            // as defined by the specification to create the filter
            const result = filter.split(":", 3);
            if (result.length === 2) result.push(null);

            // unpacks the result into it's thee components name, operator
            // and value to be used in the parsing of the filter
            const [name, operator, value] = result;

            // retrieves the definition for the filter attribute and uses
            // it to retrieve it's target data type that is going to be
            // used for the proper conversion, note that in case the base
            // type resolution method exists it's used (recursive resolution)
            const nameDefinition = this.definitionN(name);
            const nameT = nameDefinition._btype || nameDefinition.type || String;

            // determines if the current filter operation should be performed
            // using a case insensitive based approach to the search, by default
            // all of the operations are considered to be case sensitive
            const insensitive = INSENSITIVE[operator] || false;

            // retrieves the method that is going to be used for value mapping
            // or conversion based on the current operator and then converts
            // the operator into the domain specific operator
            const valueMethod = VALUE_METHODS[operator];
            const _operator = OPERATORS[operator] === undefined ? operator : OPERATORS[operator];

            // in case there's a custom value mapped retrieved uses it to convert
            // the string based value into the target specific value for the query
            // otherwise uses the data type for the search field for value conversion
            const _value = valueMethod ? valueMethod(value, nameT) : nameT(value);

            // constructs the custom find value using a key and value map value
            // in case the operator is defined otherwise (operator not defined)
            // the value is used directly, then merges this find value into the
            // current set of filters for the provided (keyword) arguments
            let findV;
            if (_operator) {
                const obj = {};
                obj[_operator] = _value;
                findV = obj;
            } else {
                findV = _value;
            }

            if (insensitive) findV.$options = "-i";
            this._filterMerge(name, findV, params, findO);
        }
    }

    /**
     * Working at a model map/dictionary level tries to resolve the
     * relations described by the sequence of `.` separated names paths.
     *
     * Should be able to handle both instance and map associated eager
     * loading relations.
     *
     * @param {Object} model The model map to be used as reference for the eager
     * loading of relations.
     * @param {Array} names The list of dot separated name paths to "guide" the
     * loading of relations (references).
     * @returns {Object} The resulting model with the required relations loaded.
     */
    static async _eager(model, names, kwargs = {}) {
        // verifies if the provided model instance is a sequence and if
        // that's the case runs the recursive eager loading of names and
        // returns the resulting sequence to the caller method
        const isList = Array.isArray(model);
        if (isList) return Promise.all(model.map(_model => this._eager(_model, names, kwargs)));

        // iterates over the complete set of names that are meant to be
        // eager loaded from the model and runs the "resolution" process
        // for each of them so that they are properly eager loaded
        for (const name of names) {
            let _model = model;
            for (const part of name.split(".")) {
                const isSequence = Array.isArray(_model);
                if (isSequence) {
                    _model = await Promise.all(_model.map(value => this._res(value, part, kwargs)));
                } else _model = await this._res(_model, part, kwargs);
                if (!_model) break;
            }
        }

        // returns the resulting model to the caller method, most of the
        // times this model should have not been touched
        return model;
    }

    /**
     * Resolves a specific model part taking into account the multiple
     * possible resolution strategies.
     *
     * Most of its logic will be associated with reference like types.
     *
     * This method will also (for map based resolution strategies) change
     * the owner model, setting its references with the resolved maps, this
     * is required as maps do not allow reference objects to exist.
     *
     * @param {Object} model The model map to be used in the resolution process.
     * @param {String} part The name of the model's part to be resolved.
     * @returns {Object} The resolved part that may be either a map or an object
     * depending on the resolution strategy.
     */
    static async _res(model, part, kwargs = {}) {
        // in case the provided is not valid returns it (no resolution is
        // possible) otherwise gather the base value for resolution
        if (!model) return model;
        let value = model[part];

        // check the data type of the requested name for resolution
        // and in case it's not valid and not a reference returns it
        // immediately, no resolution to be performed
        const isReference = TYPE_REFERENCES.some(type => value instanceof type);
        if (!value && !isReference) return value;

        // in case the value is a reference type object then runs
        // the resolve operation effectively resolving the values
        // (this is considered a very expensive operation), notice
        // that this operation is going to respect the map vs. instance
        // kind of resolution process so the data type of the resulting
        // value is going to depend on that
        if (isReference) value = await value.resolve({ eagerL: true });

        // in case the map resolution process was requested an explicit
        // set of the resolved value is required (implicit resolution
        // using `resolve()`) is not enough to ensure proper type structure
        if (kwargs.map) model[part] = value;

        // returns the "final" (possibly resolved) value to the caller method
        // ready to be used for possible merging processes
        return value;
    }

    static _findS(params) {
        // tries to retrieve the find name value from the provided
        // named arguments defaulting to an unset value otherwise
        const findN = params.find_n;
        delete params.find_n;

        // retrieves the kind of insensitive strategy that is going
        // to be used for the resolution of regular expressions,
        // this should affect all the filters and so it should be
        // used with some amount of care
        const findI = params.find_i || false;
        delete params.find_i;

        // retrieves the kind of default operation to be performed
        // this may be either: right, left or both and the default
        // value is both so that the token is matched in case it
        // appears anywhere in the search string
        const findT = params.find_t || "both";
        delete params.find_t;

        // retrieves the find string into a local variable, then
        // removes the find string from the named arguments map
        // so that it's not going to be erroneously used by the
        // underlying find infra-structure
        const findS = params.find_s;
        delete params.find_s;

        // in case the find string is currently not defined in the
        // named arguments map returns immediately as nothing is
        // meant to be done on this method
        if (!findS) return;

        // retrieves the "name" of the attribute that is considered
        // to be the default (representation) for the model in case
        // there's none returns immediately, as it's not possible
        // to proceed with the filter creation
        const defaultName = findN || this.default; // TODO DEFAULT WORKS?
        if (!defaultName) return;

        // constructs the proper right and left parts of the regex
        // that is going to be constructed for the matching of the
        // value, this is achieved by checking the find type
        const right = findT === "right" ? "^" : "";
        const left = findT === "left" ? "$" : "";

        // retrieves the definition for the default attribute and uses
        // it to retrieve it's target data type, defaulting to the
        // string type in case none is defined in the schema
        const defaultT = this.definitionN(defaultName).type || String;

        let findV;

        try {
            // in case the target date type for the default field is
            // string the both sides wildcard regex is used for the
            // search
            if (defaultT === String) {
                findV = {
                    $regex: right + escapeStringRegexp(findS) + left,
                    $options: findI ? "-i" : ""
                };
            } else {
                findV = null;
            }
        } catch (err) {
            // in case there's an error in the conversion for
            // the target type value sets the search value as
            // invalid (not going to be used in filter)
            findV = null;
        }

        if (findV) this._filterMerge(defaultName, findV, params);
    }

    static get fields() {
        return Object.keys(this.schema);
    }

    static get default() {
        const defaultEntry = Object.entries(this.schema).find(
            ([name, definition]) => definition.default
        );
        return defaultEntry ? defaultEntry[0] : null;
    }

    static definitionN(name) {
        return this.schema[name] || {};
    }

    static _filterMerge(name, filter, params, operator = null) {
        // retrieves a possible previous filter defined for the
        // provided name in case it does exist must concatenate
        // that previous value in a join statement according to
        // the currently defined operator
        const filterP = params[name];
        if (filterP || operator) {
            // defaults the operator for the join of the names to the
            // value and then ensures that the value of the operator
            // is within a valid range of values
            const _operator = operator || "$and";
            verify(["$and", "$or"].includes(_operator));

            // retrieves the and references for the current arguments
            // and appends the two filter values (current and previous)
            // then deletes the current name reference in the arguments
            // and updates the name value to the and value
            const filterA = params[_operator] || [];

            // builds the filter object assigned to the name of the
            // variable and adds to the list of values
            const _filter = {};
            _filter[name] = filter;
            filterA.push(_filter);

            // in case there's a previous filter also adds it to the
            // list of filter values
            if (filterP) {
                const _filterP = {};
                _filterP[name] = filterP;
                filterA.push(_filterP);
            }

            // updates the filter reference and updates the operator
            // name (as expected)
            filter = filterA;
            delete params[name];
            name = _operator;
        }

        // sets the currently defined filter structures in the keyword
        // based arguments map for the currently defined name
        params[name] = filter;
    }

    static get schema() {
        throw new NotImplementedError();
    }

    /**
     * Safer version of the schema structure that filters
     * some of the field attributes making it suitable to
     * be used by some of the collection adapters.
     */
    static get schemaSafe() {
        const schema = {};
        for (const [key, value] of Object.entries(this.schema)) {
            schema[key] = {
                type: value.type || String,
                index: value.index || false
            };
        }
        return schema;
    }

    static get collection() {
        if (this._collectionI) return this._collectionI;
        this._collectionI = this._collection(this.dataOptions);
        return this._collectionI;
    }

    static get idName() {
        return "id";
    }

    static get dataOptions() {
        return {
            name: this.name,
            schema: this.schemaSafe
        };
    }

    static get increments() {
        if (this._increments !== undefined) return this._increments;
        const increments = [];

        for (const [name, value] of Object.entries(this.schema)) {
            const isIncrement = value.increment || false;
            if (!isIncrement) continue;
            increments.push(name);
        }

        this._increments = increments;
        return increments;
    }

    static _collection(options) {
        const adapter = this.adapter[0].toUpperCase() + this.adapter.slice(1);
        return new collection[adapter + "Collection"](options);
    }

    static async _increment(name) {
        const _name = this.name + ":" + name;
        const store = this._collection({
            name: "counters",
            schema: {
                id: { type: String, index: true },
                seq: { type: Number }
            }
        });
        let result = await store.findOneAndUpdate(
            {
                id: _name
            },
            {
                $inc: {
                    seq: 1
                }
            },
            {
                new: true,
                upsert: true
            }
        );
        result = result || (await store.findOne({ id: _name }));
        return result.seq;
    }

    static async _ensureMin(name, value) {
        const _name = this.name + ":" + name;
        const store = this._collection({
            name: "counters",
            schema: {
                id: { type: String },
                seq: { type: Number }
            }
        });
        let result = await store.findOneAndUpdate(
            {
                id: _name
            },
            {
                $max: {
                    seq: value
                }
            },
            {
                new: true,
                upsert: true
            }
        );
        result = result || (await store.findOne({ id: _name }));
        return result.seq;
    }

    /**
     * Builds the provided list of eager values, preparing them
     * according to the current model rules.
     *
     * The composition process includes the extension of the provided
     * sequence of eager values with the base ones defined in the
     * model, if not handled correctly this is an expensive operation.
     *
     * @param {Array} eager The base sequence containing the various fields
     * that should be eagerly loaded for the operation.
     * @returns {Array} The "final" resolved array that may be used for the eager
     * loaded operation performance.
     */
    static _eagerB(eager) {
        eager = eager || [];
        eager = Array.isArray(eager) ? eager : [eager];
        eager.push(...this.eagers);
        if (eager.length === 0) return eager;
        eager = [...new Set(eager)];
        return eager;
    }

    async save({
        validate = true,
        incrementA = undefined,
        immutablesA = undefined,
        preSave = true,
        preCreate = true,
        preUpdate = true,
        postSave = true,
        postCreate = true,
        postUpdate = true,
        beforeCallbacks = [],
        afterCallbacks = []
    } = {}) {
        // in case the validate flag is set runs the model validation
        // defined for the current model
        if (validate) await this.validate();

        // calls the complete set of event handlers for the current
        // save operation, this should trigger changes in the model
        if (preSave) await this.preSave();
        if (preCreate) await this.preCreate();
        if (preUpdate) await this.preUpdate();

        // filters the values that are present in the current model
        // so that only the valid ones are stored in, invalid values
        // are going to be removed, note that if the operation is an
        // update operation and the "immutable rules" also apply, the
        // returned value is normalized meaning that for instance if
        // any relation is loaded the reference value is returned instead
        // of the loaded relation values (required for persistence)
        let model = await this._filter({
            incrementA: incrementA,
            immutablesA: immutablesA,
            normalize: true
        });

        // runs the lower layer integrity verifications that should raise
        // exception in case there's a failure
        await this.verify(model);

        // calls the complete set of callbacks that should be called
        // before the concrete data store save operation
        for (const callback of beforeCallbacks) {
            await callback(this, this.model);
        }

        // verifies if the current model is a new one or if instead
        // represents an update to a previously stored model and create
        // or update data accordingly
        const isNew = this._id === undefined;
        if (isNew) {
            model = await this.constructor.collection.create(model);
        } else {
            const conditions = {};
            conditions[this.constructor.idName] = this.identifier;
            model = await this.constructor.collection.findOneAndUpdate(conditions, model);
        }

        // wraps the model object using the current instance
        // effectively making the data available for consumers
        this.wrap(model);

        // calls the complete set of callbacks that should be called
        // after the concrete data store save operation
        for (const callback of afterCallbacks) {
            await callback(this, this.model);
        }

        // calls the post save event handlers in order to be able to
        // execute appropriate post operations
        if (postSave) await this.postSave();
        if (postCreate) await this.postCreate();
        if (postUpdate) await this.postUpdate();

        return this;
    }

    async delete({
        preDelete = true,
        postDelete = true,
        beforeCallbacks = [],
        afterCallbacks = []
    } = {}) {
        // calls the complete set of event handlers for the current
        // delete operation, this should trigger changes in the model
        if (preDelete) await this.preDelete();

        // calls the complete set of callbacks that should be called
        // before the concrete data store delete operation
        for (const callback of beforeCallbacks) {
            await callback(this, this.model);
        }

        // builds the set of conditions that rare going to be used for
        // the concrete delete operation to be performed
        const conditions = {};
        conditions[this.constructor.idName] = this.identifier;
        await this.constructor.collection.findOneAndDelete(conditions);

        // calls the complete set of callbacks that should be called
        // after the concrete data store delete operation
        for (const callback of afterCallbacks) {
            await callback(this, this.model);
        }

        // calls the complete set of event handlers for the current
        // delete operation, this should trigger changes in the model
        if (postDelete) await this.postDelete();

        return this;
    }

    async advance(name, delta = 1) {
        const conditions = {};
        conditions[this.constructor.idName] = this.identifier;
        const increments = {};
        increments[name] = delta;
        let value = await this.constructor.collection.findOneAndUpdate(
            conditions,
            {
                $inc: increments
            },
            {
                new: true
            }
        );
        value = value || (await this.constructor.collection.find_one(conditions));
        const _value = value[name];
        this[name] = _value;
        return _value;
    }

    async reload(params = {}) {
        if (this.isNew) {
            throw new OperationalError("Can't reload a new model entity", 412);
        }
        const model = await this.constructor.get({ ...params, _id: this._id });
        return model;
    }

    /**
     * Runs a series of assertions on the current model
     * definition raising assertion errors in case there
     * are issues with the internal structure of it.
     *
     * @param {Object} model The model that is going to
     * be verified for a series of elements.
     */
    async verify(model) {
        verify(
            this.getIdentifier(model) !== undefined && this.getIdentifier(model) !== null,
            "The identifier must be defined before saving",
            400,
            OperationalError
        );
        for (const [name, field] of Object.entries(this.constructor.schema)) {
            verify(
                !field.required || ![undefined, null].includes(model[name]),
                `No value provided for mandatory field '${name}'`,
                400,
                OperationalError
            );
        }
    }

    async preSave() {}

    async preCreate() {}

    async preUpdate() {}

    async preDelete() {}

    async postSave() {}

    async postCreate() {}

    async postUpdate() {}

    async postDelete() {}

    async _filter({
        incrementA = true,
        immutablesA = true,
        normalize = false,
        resolve = false,
        all = false,
        evaluator = "jsonV"
    } = {}) {
        const model = {};

        // iterates over each of the fields that are meant to have its value
        // increment and performs the appropriate operation taking into account
        // if the value is already populated or not
        for (const name of this.constructor.increments) {
            if (incrementA === false) continue;
            const exists = this.model[name] !== undefined;
            if (exists) {
                model[name] = await this.constructor._ensureMin(name, this.model[name]);
            } else {
                model[name] = await this.constructor._increment(name);
            }
        }

        // iterates over all the model items to filter the ones
        // that are not valid for the current class context
        await Promise.all(
            Object.entries(this.model).map(async ([name, value]) => {
                if (this.constructor.schema[name] === undefined) return;
                // if (immutablesA && this.immutables[name] !== undefined) return;
                model[name] = await this._evaluate(name, value, evaluator);
            })
        );

        // in case the normalize flag is set must iterate over all
        // items to try to normalize the values by calling the reference
        // value this will returns the reference index value instead of
        // the normal value that would prevent normalization
        if (normalize) {
            await Promise.all(
                Object.entries(this.model).map(async ([name, value]) => {
                    if (this.constructor.schema[name] === undefined) return;
                    if (!value || !value.refV) return;
                    model[name] = await value.refV();
                })
            );
        }

        // in case the resolution flag is set, it means that a recursive
        // approach must be performed for the resolution of values that
        // implement the map value (recursive resolution) method, this is
        // a complex (and possible computational expensive) process that
        // may imply access to the base data source
        if (resolve) {
            throw new NotImplementedError("'resolve' not implemented");
        }

        // in case the all flag is set the extra fields (not present
        // in definition) must also be used to populate the resulting
        // (filtered) map so that it contains the complete set of values
        // present in the base map of the current instance
        if (all) {
            throw new NotImplementedError("'all' not implemented");
        }

        // returns the model containing the "filtered" items resulting
        // from the validation of the items against the model class
        return model;
    }

    async _evaluate(name, value, evaluator = "jsonV") {
        // verifies if the current value is an iterable one in case
        // it is runs the evaluate method for each of the values to
        // try to resolve them into the proper representation, note
        // that both base iterable values (lists and dictionaries) and
        // objects that implement the evaluator method are not considered
        // to be iterables and normal operation applies
        let isIterable;
        try {
            isIterable = Boolean((value && value.items) || Array.isArray(value));
        } catch (error) {
            // AttributeErrors are tolerated since they might simply
            // represent a missing "items" field when dealing with
            // references
            if (!(error instanceof AttributeError)) throw error;
            isIterable = false;
        }

        const hasEvaluator = Boolean(
            evaluator && (Array.isArray(value) ? value.length : value) && value[evaluator]
        );
        isIterable = isIterable && !hasEvaluator;
        if (isIterable) {
            const result = await Promise.all(
                (value.items || value).map(item => this._evaluate(name, item, evaluator))
            );
            return result;
        }

        // verifies the current value's class is sub class of the model
        // class and in case it's extracts the relation name from the
        // value and sets it as the value in iteration
        const isModel = value instanceof Model;
        if (isModel) {
            const meta = this.constructor.definitionN(name);
            const type = meta.type || String;
            const _name = type._name;
            value = value[_name];
        }

        // iterates over all the values and retrieves the map value for
        // each of them in case the value contains a map value retrieval
        // method otherwise uses the normal value returning it to the caller
        const method = hasEvaluator ? value[evaluator] : null;
        value = method ? await method.bind(value)(false) : value;
        return value;
    }

    getIdentifier(model) {
        return model[this.constructor.idName];
    }

    get identifier() {
        return this.getIdentifier(this.model);
    }
}

class ModelMemory extends ModelStore {
    static get adapter() {
        return "memory";
    }

    static get dataOptions() {
        return Object.assign(super.dataOptions, { storage: this.storage });
    }

    static get storage() {
        return MEMORY_STORAGE[this.name];
    }
}

/**
 * Retrieves the default (initial) value for the a certain
 * provided data type falling back to the provided default
 * value in case it's not possible to retrieve a new valid
 *  default for value for the type.
 *
 * The process of retrieval of the default value to a certain
 * type may include the calling of a lambda function to obtain
 * a new instance of the default value, this avoid the usage
 * of global shared structures for the default values, that
 * could cause extremely confusing situations.
 *
 * @param {Type} type The data type object for which to retrieve its
 * default value.
 * @param {Object} _default The default value to be returned in case it's
 * not possible to retrieve a better one.
 * @returns {Object} The "final" default value for the data type according
 * to the best possible strategy.
 */
const typeD = function(type, _default = null) {
    if (TYPE_DEFAULTS[type] === undefined) return _default;
    _default = TYPE_DEFAULTS[type];
    if (typeof _default !== "function") return _default;
    return _default();
};

const ensureExpress = token => {
    return (req, res, next) => {
        ensurePermissions(token, req).catch(next).then(next);
    };
};

const yoniusRollup = function() {
    return {
        name: "yonius",
        resolveId: function(importee) {
            switch (importee) {
                case "fs":
                case "node-fetch":
                    return importee;
                default:
                    return null;
            }
        },
        load: function(id) {
            switch (id) {
                case "fs":
                    return "export const promises = {};";
                case "node-fetch":
                    return "export default fetch;";
                default:
                    return null;
            }
        }
    };
};

const NAME = name;
const VERSION = version;

export { ALIAS, API, AttributeError, Collection, FIND_DEFAULTS, FIND_TYPES, FileTuple, INSENSITIVE, MixinBuilder, Model, ModelMemory, ModelStore, MongoCollection, NAME, NotFoundError, NotImplementedError, OAuth1API, OAuth2API, OAuthAPI, OPERATORS, Observable, OperationalError, Reference, References, SORT_MAP, VALUE_METHODS, VERSION, ValidationError, YoniusError, _castR, _isDevel, _isSecure, _isValid, absoluteUrl, all, buildGetAgent, camelToUnderscore, conf, confP, confS, destroyMongo, ensureExpress, ensurePermissions, eq, equal, escapeStringRegexp, expandUser, getEnv, getEnvObject, getObject, globals, gt, gte, hasPermission, initMongo, isEmail, isIn, isLower, isPrimitive, isRegex, isSimple, isUpper, isUrl, load, load$1 as loadConf, mix, notEmpty, patchAgent, pathExists, reference, references, register, request, sizeRoundUnit, stringEq, stringGt, stringLt, toTokensM, typeD, typeof_, underscoreToCamel, unload, unregister, urlEncode, verify, verifyEqual, verifyMany, verifyNotEqual, yoniusRollup };
//# sourceMappingURL=yonius.esm.mjs.map
